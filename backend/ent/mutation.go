// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/moominzie/user-record/ent/branch"
	"github.com/moominzie/user-record/ent/building"
	"github.com/moominzie/user-record/ent/employee"
	"github.com/moominzie/user-record/ent/faculty"
	"github.com/moominzie/user-record/ent/repairinvoice"
	"github.com/moominzie/user-record/ent/returninvoice"
	"github.com/moominzie/user-record/ent/room"
	"github.com/moominzie/user-record/ent/statust"
	"github.com/moominzie/user-record/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBranch        = "Branch"
	TypeBuilding      = "Building"
	TypeEmployee      = "Employee"
	TypeFaculty       = "Faculty"
	TypeRepairinvoice = "Repairinvoice"
	TypeReturninvoice = "Returninvoice"
	TypeRoom          = "Room"
	TypeStatust       = "Statust"
	TypeUser          = "User"
)

// BranchMutation represents an operation that mutate the Branches
// nodes in the graph.
type BranchMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	brname                   *string
	clearedFields            map[string]struct{}
	faculty                  *int
	clearedfaculty           bool
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Branch, error)
}

var _ ent.Mutation = (*BranchMutation)(nil)

// branchOption allows to manage the mutation configuration using functional options.
type branchOption func(*BranchMutation)

// newBranchMutation creates new mutation for $n.Name.
func newBranchMutation(c config, op Op, opts ...branchOption) *BranchMutation {
	m := &BranchMutation{
		config:        c,
		op:            op,
		typ:           TypeBranch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBranchID sets the id field of the mutation.
func withBranchID(id int) branchOption {
	return func(m *BranchMutation) {
		var (
			err   error
			once  sync.Once
			value *Branch
		)
		m.oldValue = func(ctx context.Context) (*Branch, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Branch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBranch sets the old Branch of the mutation.
func withBranch(node *Branch) branchOption {
	return func(m *BranchMutation) {
		m.oldValue = func(context.Context) (*Branch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BranchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BranchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BranchMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBrname sets the brname field.
func (m *BranchMutation) SetBrname(s string) {
	m.brname = &s
}

// Brname returns the brname value in the mutation.
func (m *BranchMutation) Brname() (r string, exists bool) {
	v := m.brname
	if v == nil {
		return
	}
	return *v, true
}

// OldBrname returns the old brname value of the Branch.
// If the Branch object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BranchMutation) OldBrname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBrname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBrname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrname: %w", err)
	}
	return oldValue.Brname, nil
}

// ResetBrname reset all changes of the "brname" field.
func (m *BranchMutation) ResetBrname() {
	m.brname = nil
}

// SetFacultyID sets the faculty edge to Faculty by id.
func (m *BranchMutation) SetFacultyID(id int) {
	m.faculty = &id
}

// ClearFaculty clears the faculty edge to Faculty.
func (m *BranchMutation) ClearFaculty() {
	m.clearedfaculty = true
}

// FacultyCleared returns if the edge faculty was cleared.
func (m *BranchMutation) FacultyCleared() bool {
	return m.clearedfaculty
}

// FacultyID returns the faculty id in the mutation.
func (m *BranchMutation) FacultyID() (id int, exists bool) {
	if m.faculty != nil {
		return *m.faculty, true
	}
	return
}

// FacultyIDs returns the faculty ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FacultyID instead. It exists only for internal usage by the builders.
func (m *BranchMutation) FacultyIDs() (ids []int) {
	if id := m.faculty; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFaculty reset all changes of the "faculty" edge.
func (m *BranchMutation) ResetFaculty() {
	m.faculty = nil
	m.clearedfaculty = false
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *BranchMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *BranchMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *BranchMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *BranchMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *BranchMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *BranchMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Branch).
func (m *BranchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BranchMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.brname != nil {
		fields = append(fields, branch.FieldBrname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BranchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case branch.FieldBrname:
		return m.Brname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BranchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case branch.FieldBrname:
		return m.OldBrname(ctx)
	}
	return nil, fmt.Errorf("unknown Branch field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BranchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case branch.FieldBrname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrname(v)
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BranchMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BranchMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BranchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Branch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BranchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BranchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BranchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Branch nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BranchMutation) ResetField(name string) error {
	switch name {
	case branch.FieldBrname:
		m.ResetBrname()
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BranchMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.faculty != nil {
		edges = append(edges, branch.EdgeFaculty)
	}
	if m.user_informations != nil {
		edges = append(edges, branch.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BranchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeFaculty:
		if id := m.faculty; id != nil {
			return []ent.Value{*id}
		}
	case branch.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BranchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_informations != nil {
		edges = append(edges, branch.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BranchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BranchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfaculty {
		edges = append(edges, branch.EdgeFaculty)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BranchMutation) EdgeCleared(name string) bool {
	switch name {
	case branch.EdgeFaculty:
		return m.clearedfaculty
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BranchMutation) ClearEdge(name string) error {
	switch name {
	case branch.EdgeFaculty:
		m.ClearFaculty()
		return nil
	}
	return fmt.Errorf("unknown Branch unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BranchMutation) ResetEdge(name string) error {
	switch name {
	case branch.EdgeFaculty:
		m.ResetFaculty()
		return nil
	case branch.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Branch edge %s", name)
}

// BuildingMutation represents an operation that mutate the Buildings
// nodes in the graph.
type BuildingMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	buname                   *string
	clearedFields            map[string]struct{}
	rooms                    map[int]struct{}
	removedrooms             map[int]struct{}
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Building, error)
}

var _ ent.Mutation = (*BuildingMutation)(nil)

// buildingOption allows to manage the mutation configuration using functional options.
type buildingOption func(*BuildingMutation)

// newBuildingMutation creates new mutation for $n.Name.
func newBuildingMutation(c config, op Op, opts ...buildingOption) *BuildingMutation {
	m := &BuildingMutation{
		config:        c,
		op:            op,
		typ:           TypeBuilding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildingID sets the id field of the mutation.
func withBuildingID(id int) buildingOption {
	return func(m *BuildingMutation) {
		var (
			err   error
			once  sync.Once
			value *Building
		)
		m.oldValue = func(ctx context.Context) (*Building, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Building.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuilding sets the old Building of the mutation.
func withBuilding(node *Building) buildingOption {
	return func(m *BuildingMutation) {
		m.oldValue = func(context.Context) (*Building, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BuildingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBuname sets the buname field.
func (m *BuildingMutation) SetBuname(s string) {
	m.buname = &s
}

// Buname returns the buname value in the mutation.
func (m *BuildingMutation) Buname() (r string, exists bool) {
	v := m.buname
	if v == nil {
		return
	}
	return *v, true
}

// OldBuname returns the old buname value of the Building.
// If the Building object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildingMutation) OldBuname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBuname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBuname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuname: %w", err)
	}
	return oldValue.Buname, nil
}

// ResetBuname reset all changes of the "buname" field.
func (m *BuildingMutation) ResetBuname() {
	m.buname = nil
}

// AddRoomIDs adds the rooms edge to Room by ids.
func (m *BuildingMutation) AddRoomIDs(ids ...int) {
	if m.rooms == nil {
		m.rooms = make(map[int]struct{})
	}
	for i := range ids {
		m.rooms[ids[i]] = struct{}{}
	}
}

// RemoveRoomIDs removes the rooms edge to Room by ids.
func (m *BuildingMutation) RemoveRoomIDs(ids ...int) {
	if m.removedrooms == nil {
		m.removedrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrooms[ids[i]] = struct{}{}
	}
}

// RemovedRooms returns the removed ids of rooms.
func (m *BuildingMutation) RemovedRoomsIDs() (ids []int) {
	for id := range m.removedrooms {
		ids = append(ids, id)
	}
	return
}

// RoomsIDs returns the rooms ids in the mutation.
func (m *BuildingMutation) RoomsIDs() (ids []int) {
	for id := range m.rooms {
		ids = append(ids, id)
	}
	return
}

// ResetRooms reset all changes of the "rooms" edge.
func (m *BuildingMutation) ResetRooms() {
	m.rooms = nil
	m.removedrooms = nil
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *BuildingMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *BuildingMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *BuildingMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *BuildingMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *BuildingMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *BuildingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Building).
func (m *BuildingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BuildingMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.buname != nil {
		fields = append(fields, building.FieldBuname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BuildingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case building.FieldBuname:
		return m.Buname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BuildingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case building.FieldBuname:
		return m.OldBuname(ctx)
	}
	return nil, fmt.Errorf("unknown Building field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BuildingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case building.FieldBuname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuname(v)
		return nil
	}
	return fmt.Errorf("unknown Building field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BuildingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BuildingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BuildingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Building numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BuildingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BuildingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Building nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BuildingMutation) ResetField(name string) error {
	switch name {
	case building.FieldBuname:
		m.ResetBuname()
		return nil
	}
	return fmt.Errorf("unknown Building field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BuildingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.rooms != nil {
		edges = append(edges, building.EdgeRooms)
	}
	if m.user_informations != nil {
		edges = append(edges, building.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BuildingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case building.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.rooms))
		for id := range m.rooms {
			ids = append(ids, id)
		}
		return ids
	case building.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BuildingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrooms != nil {
		edges = append(edges, building.EdgeRooms)
	}
	if m.removeduser_informations != nil {
		edges = append(edges, building.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BuildingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case building.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.removedrooms))
		for id := range m.removedrooms {
			ids = append(ids, id)
		}
		return ids
	case building.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BuildingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BuildingMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BuildingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Building unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BuildingMutation) ResetEdge(name string) error {
	switch name {
	case building.EdgeRooms:
		m.ResetRooms()
		return nil
	case building.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Building edge %s", name)
}

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	employeename     *string
	employeeemail    *string
	password         *string
	clearedFields    map[string]struct{}
	employees        map[int]struct{}
	removedemployees map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmployeename sets the employeename field.
func (m *EmployeeMutation) SetEmployeename(s string) {
	m.employeename = &s
}

// Employeename returns the employeename value in the mutation.
func (m *EmployeeMutation) Employeename() (r string, exists bool) {
	v := m.employeename
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeename returns the old employeename value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeename: %w", err)
	}
	return oldValue.Employeename, nil
}

// ResetEmployeename reset all changes of the "employeename" field.
func (m *EmployeeMutation) ResetEmployeename() {
	m.employeename = nil
}

// SetEmployeeemail sets the employeeemail field.
func (m *EmployeeMutation) SetEmployeeemail(s string) {
	m.employeeemail = &s
}

// Employeeemail returns the employeeemail value in the mutation.
func (m *EmployeeMutation) Employeeemail() (r string, exists bool) {
	v := m.employeeemail
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeemail returns the old employeeemail value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeeemail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeeemail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeeemail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeemail: %w", err)
	}
	return oldValue.Employeeemail, nil
}

// ResetEmployeeemail reset all changes of the "employeeemail" field.
func (m *EmployeeMutation) ResetEmployeeemail() {
	m.employeeemail = nil
}

// SetPassword sets the password field.
func (m *EmployeeMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *EmployeeMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *EmployeeMutation) ResetPassword() {
	m.password = nil
}

// AddEmployeeIDs adds the employees edge to Returninvoice by ids.
func (m *EmployeeMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employees edge to Returninvoice by ids.
func (m *EmployeeMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed ids of employees.
func (m *EmployeeMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the employees ids in the mutation.
func (m *EmployeeMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees reset all changes of the "employees" edge.
func (m *EmployeeMutation) ResetEmployees() {
	m.employees = nil
	m.removedemployees = nil
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.employeename != nil {
		fields = append(fields, employee.FieldEmployeename)
	}
	if m.employeeemail != nil {
		fields = append(fields, employee.FieldEmployeeemail)
	}
	if m.password != nil {
		fields = append(fields, employee.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldEmployeename:
		return m.Employeename()
	case employee.FieldEmployeeemail:
		return m.Employeeemail()
	case employee.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldEmployeename:
		return m.OldEmployeename(ctx)
	case employee.FieldEmployeeemail:
		return m.OldEmployeeemail(ctx)
	case employee.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldEmployeename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeename(v)
		return nil
	case employee.FieldEmployeeemail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeemail(v)
		return nil
	case employee.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldEmployeename:
		m.ResetEmployeename()
		return nil
	case employee.FieldEmployeeemail:
		m.ResetEmployeeemail()
		return nil
	case employee.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedemployees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeEmployees:
		m.ResetEmployees()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// FacultyMutation represents an operation that mutate the Faculties
// nodes in the graph.
type FacultyMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	fname                    *string
	clearedFields            map[string]struct{}
	branchs                  map[int]struct{}
	removedbranchs           map[int]struct{}
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Faculty, error)
}

var _ ent.Mutation = (*FacultyMutation)(nil)

// facultyOption allows to manage the mutation configuration using functional options.
type facultyOption func(*FacultyMutation)

// newFacultyMutation creates new mutation for $n.Name.
func newFacultyMutation(c config, op Op, opts ...facultyOption) *FacultyMutation {
	m := &FacultyMutation{
		config:        c,
		op:            op,
		typ:           TypeFaculty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacultyID sets the id field of the mutation.
func withFacultyID(id int) facultyOption {
	return func(m *FacultyMutation) {
		var (
			err   error
			once  sync.Once
			value *Faculty
		)
		m.oldValue = func(ctx context.Context) (*Faculty, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Faculty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFaculty sets the old Faculty of the mutation.
func withFaculty(node *Faculty) facultyOption {
	return func(m *FacultyMutation) {
		m.oldValue = func(context.Context) (*Faculty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacultyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacultyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FacultyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFname sets the fname field.
func (m *FacultyMutation) SetFname(s string) {
	m.fname = &s
}

// Fname returns the fname value in the mutation.
func (m *FacultyMutation) Fname() (r string, exists bool) {
	v := m.fname
	if v == nil {
		return
	}
	return *v, true
}

// OldFname returns the old fname value of the Faculty.
// If the Faculty object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FacultyMutation) OldFname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFname: %w", err)
	}
	return oldValue.Fname, nil
}

// ResetFname reset all changes of the "fname" field.
func (m *FacultyMutation) ResetFname() {
	m.fname = nil
}

// AddBranchIDs adds the branchs edge to Branch by ids.
func (m *FacultyMutation) AddBranchIDs(ids ...int) {
	if m.branchs == nil {
		m.branchs = make(map[int]struct{})
	}
	for i := range ids {
		m.branchs[ids[i]] = struct{}{}
	}
}

// RemoveBranchIDs removes the branchs edge to Branch by ids.
func (m *FacultyMutation) RemoveBranchIDs(ids ...int) {
	if m.removedbranchs == nil {
		m.removedbranchs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbranchs[ids[i]] = struct{}{}
	}
}

// RemovedBranchs returns the removed ids of branchs.
func (m *FacultyMutation) RemovedBranchsIDs() (ids []int) {
	for id := range m.removedbranchs {
		ids = append(ids, id)
	}
	return
}

// BranchsIDs returns the branchs ids in the mutation.
func (m *FacultyMutation) BranchsIDs() (ids []int) {
	for id := range m.branchs {
		ids = append(ids, id)
	}
	return
}

// ResetBranchs reset all changes of the "branchs" edge.
func (m *FacultyMutation) ResetBranchs() {
	m.branchs = nil
	m.removedbranchs = nil
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *FacultyMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *FacultyMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *FacultyMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *FacultyMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *FacultyMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *FacultyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Faculty).
func (m *FacultyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FacultyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.fname != nil {
		fields = append(fields, faculty.FieldFname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FacultyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case faculty.FieldFname:
		return m.Fname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FacultyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case faculty.FieldFname:
		return m.OldFname(ctx)
	}
	return nil, fmt.Errorf("unknown Faculty field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacultyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case faculty.FieldFname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFname(v)
		return nil
	}
	return fmt.Errorf("unknown Faculty field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FacultyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FacultyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacultyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Faculty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FacultyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FacultyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacultyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Faculty nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FacultyMutation) ResetField(name string) error {
	switch name {
	case faculty.FieldFname:
		m.ResetFname()
		return nil
	}
	return fmt.Errorf("unknown Faculty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FacultyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.branchs != nil {
		edges = append(edges, faculty.EdgeBranchs)
	}
	if m.user_informations != nil {
		edges = append(edges, faculty.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FacultyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case faculty.EdgeBranchs:
		ids := make([]ent.Value, 0, len(m.branchs))
		for id := range m.branchs {
			ids = append(ids, id)
		}
		return ids
	case faculty.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FacultyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbranchs != nil {
		edges = append(edges, faculty.EdgeBranchs)
	}
	if m.removeduser_informations != nil {
		edges = append(edges, faculty.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FacultyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case faculty.EdgeBranchs:
		ids := make([]ent.Value, 0, len(m.removedbranchs))
		for id := range m.removedbranchs {
			ids = append(ids, id)
		}
		return ids
	case faculty.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FacultyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FacultyMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FacultyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Faculty unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FacultyMutation) ResetEdge(name string) error {
	switch name {
	case faculty.EdgeBranchs:
		m.ResetBranchs()
		return nil
	case faculty.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Faculty edge %s", name)
}

// RepairinvoiceMutation represents an operation that mutate the Repairinvoices
// nodes in the graph.
type RepairinvoiceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	symptomid             *int
	addsymptomid          *int
	deviceid              *int
	adddeviceid           *int
	userid                *int
	adduserid             *int
	statusrepairid        *int
	addstatusrepairid     *int
	clearedFields         map[string]struct{}
	repairinvoices        *int
	clearedrepairinvoices bool
	done                  bool
	oldValue              func(context.Context) (*Repairinvoice, error)
}

var _ ent.Mutation = (*RepairinvoiceMutation)(nil)

// repairinvoiceOption allows to manage the mutation configuration using functional options.
type repairinvoiceOption func(*RepairinvoiceMutation)

// newRepairinvoiceMutation creates new mutation for $n.Name.
func newRepairinvoiceMutation(c config, op Op, opts ...repairinvoiceOption) *RepairinvoiceMutation {
	m := &RepairinvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeRepairinvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepairinvoiceID sets the id field of the mutation.
func withRepairinvoiceID(id int) repairinvoiceOption {
	return func(m *RepairinvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Repairinvoice
		)
		m.oldValue = func(ctx context.Context) (*Repairinvoice, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repairinvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepairinvoice sets the old Repairinvoice of the mutation.
func withRepairinvoice(node *Repairinvoice) repairinvoiceOption {
	return func(m *RepairinvoiceMutation) {
		m.oldValue = func(context.Context) (*Repairinvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepairinvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepairinvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RepairinvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSymptomid sets the symptomid field.
func (m *RepairinvoiceMutation) SetSymptomid(i int) {
	m.symptomid = &i
	m.addsymptomid = nil
}

// Symptomid returns the symptomid value in the mutation.
func (m *RepairinvoiceMutation) Symptomid() (r int, exists bool) {
	v := m.symptomid
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptomid returns the old symptomid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldSymptomid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptomid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptomid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptomid: %w", err)
	}
	return oldValue.Symptomid, nil
}

// AddSymptomid adds i to symptomid.
func (m *RepairinvoiceMutation) AddSymptomid(i int) {
	if m.addsymptomid != nil {
		*m.addsymptomid += i
	} else {
		m.addsymptomid = &i
	}
}

// AddedSymptomid returns the value that was added to the symptomid field in this mutation.
func (m *RepairinvoiceMutation) AddedSymptomid() (r int, exists bool) {
	v := m.addsymptomid
	if v == nil {
		return
	}
	return *v, true
}

// ResetSymptomid reset all changes of the "symptomid" field.
func (m *RepairinvoiceMutation) ResetSymptomid() {
	m.symptomid = nil
	m.addsymptomid = nil
}

// SetDeviceid sets the deviceid field.
func (m *RepairinvoiceMutation) SetDeviceid(i int) {
	m.deviceid = &i
	m.adddeviceid = nil
}

// Deviceid returns the deviceid value in the mutation.
func (m *RepairinvoiceMutation) Deviceid() (r int, exists bool) {
	v := m.deviceid
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceid returns the old deviceid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldDeviceid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceid: %w", err)
	}
	return oldValue.Deviceid, nil
}

// AddDeviceid adds i to deviceid.
func (m *RepairinvoiceMutation) AddDeviceid(i int) {
	if m.adddeviceid != nil {
		*m.adddeviceid += i
	} else {
		m.adddeviceid = &i
	}
}

// AddedDeviceid returns the value that was added to the deviceid field in this mutation.
func (m *RepairinvoiceMutation) AddedDeviceid() (r int, exists bool) {
	v := m.adddeviceid
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceid reset all changes of the "deviceid" field.
func (m *RepairinvoiceMutation) ResetDeviceid() {
	m.deviceid = nil
	m.adddeviceid = nil
}

// SetUserid sets the userid field.
func (m *RepairinvoiceMutation) SetUserid(i int) {
	m.userid = &i
	m.adduserid = nil
}

// Userid returns the userid value in the mutation.
func (m *RepairinvoiceMutation) Userid() (r int, exists bool) {
	v := m.userid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserid returns the old userid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldUserid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserid: %w", err)
	}
	return oldValue.Userid, nil
}

// AddUserid adds i to userid.
func (m *RepairinvoiceMutation) AddUserid(i int) {
	if m.adduserid != nil {
		*m.adduserid += i
	} else {
		m.adduserid = &i
	}
}

// AddedUserid returns the value that was added to the userid field in this mutation.
func (m *RepairinvoiceMutation) AddedUserid() (r int, exists bool) {
	v := m.adduserid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserid reset all changes of the "userid" field.
func (m *RepairinvoiceMutation) ResetUserid() {
	m.userid = nil
	m.adduserid = nil
}

// SetStatusrepairid sets the statusrepairid field.
func (m *RepairinvoiceMutation) SetStatusrepairid(i int) {
	m.statusrepairid = &i
	m.addstatusrepairid = nil
}

// Statusrepairid returns the statusrepairid value in the mutation.
func (m *RepairinvoiceMutation) Statusrepairid() (r int, exists bool) {
	v := m.statusrepairid
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusrepairid returns the old statusrepairid value of the Repairinvoice.
// If the Repairinvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairinvoiceMutation) OldStatusrepairid(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusrepairid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusrepairid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusrepairid: %w", err)
	}
	return oldValue.Statusrepairid, nil
}

// AddStatusrepairid adds i to statusrepairid.
func (m *RepairinvoiceMutation) AddStatusrepairid(i int) {
	if m.addstatusrepairid != nil {
		*m.addstatusrepairid += i
	} else {
		m.addstatusrepairid = &i
	}
}

// AddedStatusrepairid returns the value that was added to the statusrepairid field in this mutation.
func (m *RepairinvoiceMutation) AddedStatusrepairid() (r int, exists bool) {
	v := m.addstatusrepairid
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusrepairid reset all changes of the "statusrepairid" field.
func (m *RepairinvoiceMutation) ResetStatusrepairid() {
	m.statusrepairid = nil
	m.addstatusrepairid = nil
}

// SetRepairinvoicesID sets the repairinvoices edge to Returninvoice by id.
func (m *RepairinvoiceMutation) SetRepairinvoicesID(id int) {
	m.repairinvoices = &id
}

// ClearRepairinvoices clears the repairinvoices edge to Returninvoice.
func (m *RepairinvoiceMutation) ClearRepairinvoices() {
	m.clearedrepairinvoices = true
}

// RepairinvoicesCleared returns if the edge repairinvoices was cleared.
func (m *RepairinvoiceMutation) RepairinvoicesCleared() bool {
	return m.clearedrepairinvoices
}

// RepairinvoicesID returns the repairinvoices id in the mutation.
func (m *RepairinvoiceMutation) RepairinvoicesID() (id int, exists bool) {
	if m.repairinvoices != nil {
		return *m.repairinvoices, true
	}
	return
}

// RepairinvoicesIDs returns the repairinvoices ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RepairinvoicesID instead. It exists only for internal usage by the builders.
func (m *RepairinvoiceMutation) RepairinvoicesIDs() (ids []int) {
	if id := m.repairinvoices; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepairinvoices reset all changes of the "repairinvoices" edge.
func (m *RepairinvoiceMutation) ResetRepairinvoices() {
	m.repairinvoices = nil
	m.clearedrepairinvoices = false
}

// Op returns the operation name.
func (m *RepairinvoiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repairinvoice).
func (m *RepairinvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RepairinvoiceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.symptomid != nil {
		fields = append(fields, repairinvoice.FieldSymptomid)
	}
	if m.deviceid != nil {
		fields = append(fields, repairinvoice.FieldDeviceid)
	}
	if m.userid != nil {
		fields = append(fields, repairinvoice.FieldUserid)
	}
	if m.statusrepairid != nil {
		fields = append(fields, repairinvoice.FieldStatusrepairid)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RepairinvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repairinvoice.FieldSymptomid:
		return m.Symptomid()
	case repairinvoice.FieldDeviceid:
		return m.Deviceid()
	case repairinvoice.FieldUserid:
		return m.Userid()
	case repairinvoice.FieldStatusrepairid:
		return m.Statusrepairid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RepairinvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repairinvoice.FieldSymptomid:
		return m.OldSymptomid(ctx)
	case repairinvoice.FieldDeviceid:
		return m.OldDeviceid(ctx)
	case repairinvoice.FieldUserid:
		return m.OldUserid(ctx)
	case repairinvoice.FieldStatusrepairid:
		return m.OldStatusrepairid(ctx)
	}
	return nil, fmt.Errorf("unknown Repairinvoice field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairinvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repairinvoice.FieldSymptomid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptomid(v)
		return nil
	case repairinvoice.FieldDeviceid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceid(v)
		return nil
	case repairinvoice.FieldUserid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserid(v)
		return nil
	case repairinvoice.FieldStatusrepairid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusrepairid(v)
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RepairinvoiceMutation) AddedFields() []string {
	var fields []string
	if m.addsymptomid != nil {
		fields = append(fields, repairinvoice.FieldSymptomid)
	}
	if m.adddeviceid != nil {
		fields = append(fields, repairinvoice.FieldDeviceid)
	}
	if m.adduserid != nil {
		fields = append(fields, repairinvoice.FieldUserid)
	}
	if m.addstatusrepairid != nil {
		fields = append(fields, repairinvoice.FieldStatusrepairid)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RepairinvoiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case repairinvoice.FieldSymptomid:
		return m.AddedSymptomid()
	case repairinvoice.FieldDeviceid:
		return m.AddedDeviceid()
	case repairinvoice.FieldUserid:
		return m.AddedUserid()
	case repairinvoice.FieldStatusrepairid:
		return m.AddedStatusrepairid()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairinvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case repairinvoice.FieldSymptomid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSymptomid(v)
		return nil
	case repairinvoice.FieldDeviceid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceid(v)
		return nil
	case repairinvoice.FieldUserid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserid(v)
		return nil
	case repairinvoice.FieldStatusrepairid:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusrepairid(v)
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RepairinvoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RepairinvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepairinvoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repairinvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RepairinvoiceMutation) ResetField(name string) error {
	switch name {
	case repairinvoice.FieldSymptomid:
		m.ResetSymptomid()
		return nil
	case repairinvoice.FieldDeviceid:
		m.ResetDeviceid()
		return nil
	case repairinvoice.FieldUserid:
		m.ResetUserid()
		return nil
	case repairinvoice.FieldStatusrepairid:
		m.ResetStatusrepairid()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RepairinvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repairinvoices != nil {
		edges = append(edges, repairinvoice.EdgeRepairinvoices)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RepairinvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		if id := m.repairinvoices; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RepairinvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RepairinvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RepairinvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrepairinvoices {
		edges = append(edges, repairinvoice.EdgeRepairinvoices)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RepairinvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		return m.clearedrepairinvoices
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RepairinvoiceMutation) ClearEdge(name string) error {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		m.ClearRepairinvoices()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RepairinvoiceMutation) ResetEdge(name string) error {
	switch name {
	case repairinvoice.EdgeRepairinvoices:
		m.ResetRepairinvoices()
		return nil
	}
	return fmt.Errorf("unknown Repairinvoice edge %s", name)
}

// ReturninvoiceMutation represents an operation that mutate the Returninvoices
// nodes in the graph.
type ReturninvoiceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	addedtime             *time.Time
	clearedFields         map[string]struct{}
	_Repairinvoice        *int
	cleared_Repairinvoice bool
	_Employee             *int
	cleared_Employee      bool
	_Statust              *int
	cleared_Statust       bool
	done                  bool
	oldValue              func(context.Context) (*Returninvoice, error)
}

var _ ent.Mutation = (*ReturninvoiceMutation)(nil)

// returninvoiceOption allows to manage the mutation configuration using functional options.
type returninvoiceOption func(*ReturninvoiceMutation)

// newReturninvoiceMutation creates new mutation for $n.Name.
func newReturninvoiceMutation(c config, op Op, opts ...returninvoiceOption) *ReturninvoiceMutation {
	m := &ReturninvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeReturninvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReturninvoiceID sets the id field of the mutation.
func withReturninvoiceID(id int) returninvoiceOption {
	return func(m *ReturninvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Returninvoice
		)
		m.oldValue = func(ctx context.Context) (*Returninvoice, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Returninvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReturninvoice sets the old Returninvoice of the mutation.
func withReturninvoice(node *Returninvoice) returninvoiceOption {
	return func(m *ReturninvoiceMutation) {
		m.oldValue = func(context.Context) (*Returninvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReturninvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReturninvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ReturninvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the addedtime field.
func (m *ReturninvoiceMutation) SetAddedtime(t time.Time) {
	m.addedtime = &t
}

// Addedtime returns the addedtime value in the mutation.
func (m *ReturninvoiceMutation) Addedtime() (r time.Time, exists bool) {
	v := m.addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old addedtime value of the Returninvoice.
// If the Returninvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReturninvoiceMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime reset all changes of the "addedtime" field.
func (m *ReturninvoiceMutation) ResetAddedtime() {
	m.addedtime = nil
}

// SetRepairinvoiceID sets the Repairinvoice edge to Repairinvoice by id.
func (m *ReturninvoiceMutation) SetRepairinvoiceID(id int) {
	m._Repairinvoice = &id
}

// ClearRepairinvoice clears the Repairinvoice edge to Repairinvoice.
func (m *ReturninvoiceMutation) ClearRepairinvoice() {
	m.cleared_Repairinvoice = true
}

// RepairinvoiceCleared returns if the edge Repairinvoice was cleared.
func (m *ReturninvoiceMutation) RepairinvoiceCleared() bool {
	return m.cleared_Repairinvoice
}

// RepairinvoiceID returns the Repairinvoice id in the mutation.
func (m *ReturninvoiceMutation) RepairinvoiceID() (id int, exists bool) {
	if m._Repairinvoice != nil {
		return *m._Repairinvoice, true
	}
	return
}

// RepairinvoiceIDs returns the Repairinvoice ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RepairinvoiceID instead. It exists only for internal usage by the builders.
func (m *ReturninvoiceMutation) RepairinvoiceIDs() (ids []int) {
	if id := m._Repairinvoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepairinvoice reset all changes of the "Repairinvoice" edge.
func (m *ReturninvoiceMutation) ResetRepairinvoice() {
	m._Repairinvoice = nil
	m.cleared_Repairinvoice = false
}

// SetEmployeeID sets the Employee edge to Employee by id.
func (m *ReturninvoiceMutation) SetEmployeeID(id int) {
	m._Employee = &id
}

// ClearEmployee clears the Employee edge to Employee.
func (m *ReturninvoiceMutation) ClearEmployee() {
	m.cleared_Employee = true
}

// EmployeeCleared returns if the edge Employee was cleared.
func (m *ReturninvoiceMutation) EmployeeCleared() bool {
	return m.cleared_Employee
}

// EmployeeID returns the Employee id in the mutation.
func (m *ReturninvoiceMutation) EmployeeID() (id int, exists bool) {
	if m._Employee != nil {
		return *m._Employee, true
	}
	return
}

// EmployeeIDs returns the Employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *ReturninvoiceMutation) EmployeeIDs() (ids []int) {
	if id := m._Employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "Employee" edge.
func (m *ReturninvoiceMutation) ResetEmployee() {
	m._Employee = nil
	m.cleared_Employee = false
}

// SetStatustID sets the Statust edge to Statust by id.
func (m *ReturninvoiceMutation) SetStatustID(id int) {
	m._Statust = &id
}

// ClearStatust clears the Statust edge to Statust.
func (m *ReturninvoiceMutation) ClearStatust() {
	m.cleared_Statust = true
}

// StatustCleared returns if the edge Statust was cleared.
func (m *ReturninvoiceMutation) StatustCleared() bool {
	return m.cleared_Statust
}

// StatustID returns the Statust id in the mutation.
func (m *ReturninvoiceMutation) StatustID() (id int, exists bool) {
	if m._Statust != nil {
		return *m._Statust, true
	}
	return
}

// StatustIDs returns the Statust ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StatustID instead. It exists only for internal usage by the builders.
func (m *ReturninvoiceMutation) StatustIDs() (ids []int) {
	if id := m._Statust; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatust reset all changes of the "Statust" edge.
func (m *ReturninvoiceMutation) ResetStatust() {
	m._Statust = nil
	m.cleared_Statust = false
}

// Op returns the operation name.
func (m *ReturninvoiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Returninvoice).
func (m *ReturninvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ReturninvoiceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.addedtime != nil {
		fields = append(fields, returninvoice.FieldAddedtime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ReturninvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case returninvoice.FieldAddedtime:
		return m.Addedtime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ReturninvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case returninvoice.FieldAddedtime:
		return m.OldAddedtime(ctx)
	}
	return nil, fmt.Errorf("unknown Returninvoice field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReturninvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case returninvoice.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	}
	return fmt.Errorf("unknown Returninvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ReturninvoiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ReturninvoiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReturninvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Returninvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ReturninvoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ReturninvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReturninvoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Returninvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ReturninvoiceMutation) ResetField(name string) error {
	switch name {
	case returninvoice.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	}
	return fmt.Errorf("unknown Returninvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ReturninvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Repairinvoice != nil {
		edges = append(edges, returninvoice.EdgeRepairinvoice)
	}
	if m._Employee != nil {
		edges = append(edges, returninvoice.EdgeEmployee)
	}
	if m._Statust != nil {
		edges = append(edges, returninvoice.EdgeStatust)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ReturninvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		if id := m._Repairinvoice; id != nil {
			return []ent.Value{*id}
		}
	case returninvoice.EdgeEmployee:
		if id := m._Employee; id != nil {
			return []ent.Value{*id}
		}
	case returninvoice.EdgeStatust:
		if id := m._Statust; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ReturninvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ReturninvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ReturninvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Repairinvoice {
		edges = append(edges, returninvoice.EdgeRepairinvoice)
	}
	if m.cleared_Employee {
		edges = append(edges, returninvoice.EdgeEmployee)
	}
	if m.cleared_Statust {
		edges = append(edges, returninvoice.EdgeStatust)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ReturninvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		return m.cleared_Repairinvoice
	case returninvoice.EdgeEmployee:
		return m.cleared_Employee
	case returninvoice.EdgeStatust:
		return m.cleared_Statust
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ReturninvoiceMutation) ClearEdge(name string) error {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		m.ClearRepairinvoice()
		return nil
	case returninvoice.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case returninvoice.EdgeStatust:
		m.ClearStatust()
		return nil
	}
	return fmt.Errorf("unknown Returninvoice unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ReturninvoiceMutation) ResetEdge(name string) error {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		m.ResetRepairinvoice()
		return nil
	case returninvoice.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case returninvoice.EdgeStatust:
		m.ResetStatust()
		return nil
	}
	return fmt.Errorf("unknown Returninvoice edge %s", name)
}

// RoomMutation represents an operation that mutate the Rooms
// nodes in the graph.
type RoomMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	rname                    *string
	clearedFields            map[string]struct{}
	building                 *int
	clearedbuilding          bool
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Room, error)
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows to manage the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for $n.Name.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the id field of the mutation.
func withRoomID(id int) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRname sets the rname field.
func (m *RoomMutation) SetRname(s string) {
	m.rname = &s
}

// Rname returns the rname value in the mutation.
func (m *RoomMutation) Rname() (r string, exists bool) {
	v := m.rname
	if v == nil {
		return
	}
	return *v, true
}

// OldRname returns the old rname value of the Room.
// If the Room object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomMutation) OldRname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRname: %w", err)
	}
	return oldValue.Rname, nil
}

// ResetRname reset all changes of the "rname" field.
func (m *RoomMutation) ResetRname() {
	m.rname = nil
}

// SetBuildingID sets the building edge to Building by id.
func (m *RoomMutation) SetBuildingID(id int) {
	m.building = &id
}

// ClearBuilding clears the building edge to Building.
func (m *RoomMutation) ClearBuilding() {
	m.clearedbuilding = true
}

// BuildingCleared returns if the edge building was cleared.
func (m *RoomMutation) BuildingCleared() bool {
	return m.clearedbuilding
}

// BuildingID returns the building id in the mutation.
func (m *RoomMutation) BuildingID() (id int, exists bool) {
	if m.building != nil {
		return *m.building, true
	}
	return
}

// BuildingIDs returns the building ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BuildingID instead. It exists only for internal usage by the builders.
func (m *RoomMutation) BuildingIDs() (ids []int) {
	if id := m.building; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuilding reset all changes of the "building" edge.
func (m *RoomMutation) ResetBuilding() {
	m.building = nil
	m.clearedbuilding = false
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *RoomMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *RoomMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *RoomMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *RoomMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *RoomMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.rname != nil {
		fields = append(fields, room.FieldRname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldRname:
		return m.Rname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldRname:
		return m.OldRname(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldRname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRname(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldRname:
		m.ResetRname()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.building != nil {
		edges = append(edges, room.EdgeBuilding)
	}
	if m.user_informations != nil {
		edges = append(edges, room.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeBuilding:
		if id := m.building; id != nil {
			return []ent.Value{*id}
		}
	case room.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_informations != nil {
		edges = append(edges, room.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbuilding {
		edges = append(edges, room.EdgeBuilding)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	case room.EdgeBuilding:
		return m.clearedbuilding
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	case room.EdgeBuilding:
		m.ClearBuilding()
		return nil
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgeBuilding:
		m.ResetBuilding()
		return nil
	case room.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// StatustMutation represents an operation that mutate the Statusts
// nodes in the graph.
type StatustMutation struct {
	config
	op              Op
	typ             string
	id              *int
	statustname     *string
	clearedFields   map[string]struct{}
	statusts        map[int]struct{}
	removedstatusts map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Statust, error)
}

var _ ent.Mutation = (*StatustMutation)(nil)

// statustOption allows to manage the mutation configuration using functional options.
type statustOption func(*StatustMutation)

// newStatustMutation creates new mutation for $n.Name.
func newStatustMutation(c config, op Op, opts ...statustOption) *StatustMutation {
	m := &StatustMutation{
		config:        c,
		op:            op,
		typ:           TypeStatust,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatustID sets the id field of the mutation.
func withStatustID(id int) statustOption {
	return func(m *StatustMutation) {
		var (
			err   error
			once  sync.Once
			value *Statust
		)
		m.oldValue = func(ctx context.Context) (*Statust, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statust.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatust sets the old Statust of the mutation.
func withStatust(node *Statust) statustOption {
	return func(m *StatustMutation) {
		m.oldValue = func(context.Context) (*Statust, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatustMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatustMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatustMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatustname sets the statustname field.
func (m *StatustMutation) SetStatustname(s string) {
	m.statustname = &s
}

// Statustname returns the statustname value in the mutation.
func (m *StatustMutation) Statustname() (r string, exists bool) {
	v := m.statustname
	if v == nil {
		return
	}
	return *v, true
}

// OldStatustname returns the old statustname value of the Statust.
// If the Statust object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatustMutation) OldStatustname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatustname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatustname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatustname: %w", err)
	}
	return oldValue.Statustname, nil
}

// ResetStatustname reset all changes of the "statustname" field.
func (m *StatustMutation) ResetStatustname() {
	m.statustname = nil
}

// AddStatustIDs adds the statusts edge to Returninvoice by ids.
func (m *StatustMutation) AddStatustIDs(ids ...int) {
	if m.statusts == nil {
		m.statusts = make(map[int]struct{})
	}
	for i := range ids {
		m.statusts[ids[i]] = struct{}{}
	}
}

// RemoveStatustIDs removes the statusts edge to Returninvoice by ids.
func (m *StatustMutation) RemoveStatustIDs(ids ...int) {
	if m.removedstatusts == nil {
		m.removedstatusts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatusts[ids[i]] = struct{}{}
	}
}

// RemovedStatusts returns the removed ids of statusts.
func (m *StatustMutation) RemovedStatustsIDs() (ids []int) {
	for id := range m.removedstatusts {
		ids = append(ids, id)
	}
	return
}

// StatustsIDs returns the statusts ids in the mutation.
func (m *StatustMutation) StatustsIDs() (ids []int) {
	for id := range m.statusts {
		ids = append(ids, id)
	}
	return
}

// ResetStatusts reset all changes of the "statusts" edge.
func (m *StatustMutation) ResetStatusts() {
	m.statusts = nil
	m.removedstatusts = nil
}

// Op returns the operation name.
func (m *StatustMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Statust).
func (m *StatustMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatustMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.statustname != nil {
		fields = append(fields, statust.FieldStatustname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatustMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statust.FieldStatustname:
		return m.Statustname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatustMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statust.FieldStatustname:
		return m.OldStatustname(ctx)
	}
	return nil, fmt.Errorf("unknown Statust field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatustMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statust.FieldStatustname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatustname(v)
		return nil
	}
	return fmt.Errorf("unknown Statust field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatustMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatustMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatustMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Statust numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatustMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatustMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatustMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Statust nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatustMutation) ResetField(name string) error {
	switch name {
	case statust.FieldStatustname:
		m.ResetStatustname()
		return nil
	}
	return fmt.Errorf("unknown Statust field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatustMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.statusts != nil {
		edges = append(edges, statust.EdgeStatusts)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatustMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statust.EdgeStatusts:
		ids := make([]ent.Value, 0, len(m.statusts))
		for id := range m.statusts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatustMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstatusts != nil {
		edges = append(edges, statust.EdgeStatusts)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatustMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statust.EdgeStatusts:
		ids := make([]ent.Value, 0, len(m.removedstatusts))
		for id := range m.removedstatusts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatustMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatustMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatustMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Statust unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatustMutation) ResetEdge(name string) error {
	switch name {
	case statust.EdgeStatusts:
		m.ResetStatusts()
		return nil
	}
	return fmt.Errorf("unknown Statust edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	personalID      *string
	personalName    *string
	clearedFields   map[string]struct{}
	faculty         *int
	clearedfaculty  bool
	branch          *int
	clearedbranch   bool
	building        *int
	clearedbuilding bool
	room            *int
	clearedroom     bool
	done            bool
	oldValue        func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPersonalID sets the personalID field.
func (m *UserMutation) SetPersonalID(s string) {
	m.personalID = &s
}

// PersonalID returns the personalID value in the mutation.
func (m *UserMutation) PersonalID() (r string, exists bool) {
	v := m.personalID
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalID returns the old personalID value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPersonalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPersonalID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPersonalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalID: %w", err)
	}
	return oldValue.PersonalID, nil
}

// ResetPersonalID reset all changes of the "personalID" field.
func (m *UserMutation) ResetPersonalID() {
	m.personalID = nil
}

// SetPersonalName sets the personalName field.
func (m *UserMutation) SetPersonalName(s string) {
	m.personalName = &s
}

// PersonalName returns the personalName value in the mutation.
func (m *UserMutation) PersonalName() (r string, exists bool) {
	v := m.personalName
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalName returns the old personalName value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPersonalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPersonalName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPersonalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalName: %w", err)
	}
	return oldValue.PersonalName, nil
}

// ResetPersonalName reset all changes of the "personalName" field.
func (m *UserMutation) ResetPersonalName() {
	m.personalName = nil
}

// SetFacultyID sets the faculty edge to Faculty by id.
func (m *UserMutation) SetFacultyID(id int) {
	m.faculty = &id
}

// ClearFaculty clears the faculty edge to Faculty.
func (m *UserMutation) ClearFaculty() {
	m.clearedfaculty = true
}

// FacultyCleared returns if the edge faculty was cleared.
func (m *UserMutation) FacultyCleared() bool {
	return m.clearedfaculty
}

// FacultyID returns the faculty id in the mutation.
func (m *UserMutation) FacultyID() (id int, exists bool) {
	if m.faculty != nil {
		return *m.faculty, true
	}
	return
}

// FacultyIDs returns the faculty ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FacultyID instead. It exists only for internal usage by the builders.
func (m *UserMutation) FacultyIDs() (ids []int) {
	if id := m.faculty; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFaculty reset all changes of the "faculty" edge.
func (m *UserMutation) ResetFaculty() {
	m.faculty = nil
	m.clearedfaculty = false
}

// SetBranchID sets the branch edge to Branch by id.
func (m *UserMutation) SetBranchID(id int) {
	m.branch = &id
}

// ClearBranch clears the branch edge to Branch.
func (m *UserMutation) ClearBranch() {
	m.clearedbranch = true
}

// BranchCleared returns if the edge branch was cleared.
func (m *UserMutation) BranchCleared() bool {
	return m.clearedbranch
}

// BranchID returns the branch id in the mutation.
func (m *UserMutation) BranchID() (id int, exists bool) {
	if m.branch != nil {
		return *m.branch, true
	}
	return
}

// BranchIDs returns the branch ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BranchIDs() (ids []int) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch reset all changes of the "branch" edge.
func (m *UserMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// SetBuildingID sets the building edge to Building by id.
func (m *UserMutation) SetBuildingID(id int) {
	m.building = &id
}

// ClearBuilding clears the building edge to Building.
func (m *UserMutation) ClearBuilding() {
	m.clearedbuilding = true
}

// BuildingCleared returns if the edge building was cleared.
func (m *UserMutation) BuildingCleared() bool {
	return m.clearedbuilding
}

// BuildingID returns the building id in the mutation.
func (m *UserMutation) BuildingID() (id int, exists bool) {
	if m.building != nil {
		return *m.building, true
	}
	return
}

// BuildingIDs returns the building ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BuildingID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BuildingIDs() (ids []int) {
	if id := m.building; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuilding reset all changes of the "building" edge.
func (m *UserMutation) ResetBuilding() {
	m.building = nil
	m.clearedbuilding = false
}

// SetRoomID sets the room edge to Room by id.
func (m *UserMutation) SetRoomID(id int) {
	m.room = &id
}

// ClearRoom clears the room edge to Room.
func (m *UserMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared returns if the edge room was cleared.
func (m *UserMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomID returns the room id in the mutation.
func (m *UserMutation) RoomID() (id int, exists bool) {
	if m.room != nil {
		return *m.room, true
	}
	return
}

// RoomIDs returns the room ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RoomIDs() (ids []int) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom reset all changes of the "room" edge.
func (m *UserMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.personalID != nil {
		fields = append(fields, user.FieldPersonalID)
	}
	if m.personalName != nil {
		fields = append(fields, user.FieldPersonalName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldPersonalID:
		return m.PersonalID()
	case user.FieldPersonalName:
		return m.PersonalName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldPersonalID:
		return m.OldPersonalID(ctx)
	case user.FieldPersonalName:
		return m.OldPersonalName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldPersonalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalID(v)
		return nil
	case user.FieldPersonalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldPersonalID:
		m.ResetPersonalID()
		return nil
	case user.FieldPersonalName:
		m.ResetPersonalName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.faculty != nil {
		edges = append(edges, user.EdgeFaculty)
	}
	if m.branch != nil {
		edges = append(edges, user.EdgeBranch)
	}
	if m.building != nil {
		edges = append(edges, user.EdgeBuilding)
	}
	if m.room != nil {
		edges = append(edges, user.EdgeRoom)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeFaculty:
		if id := m.faculty; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeBuilding:
		if id := m.building; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedfaculty {
		edges = append(edges, user.EdgeFaculty)
	}
	if m.clearedbranch {
		edges = append(edges, user.EdgeBranch)
	}
	if m.clearedbuilding {
		edges = append(edges, user.EdgeBuilding)
	}
	if m.clearedroom {
		edges = append(edges, user.EdgeRoom)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeFaculty:
		return m.clearedfaculty
	case user.EdgeBranch:
		return m.clearedbranch
	case user.EdgeBuilding:
		return m.clearedbuilding
	case user.EdgeRoom:
		return m.clearedroom
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeFaculty:
		m.ClearFaculty()
		return nil
	case user.EdgeBranch:
		m.ClearBranch()
		return nil
	case user.EdgeBuilding:
		m.ClearBuilding()
		return nil
	case user.EdgeRoom:
		m.ClearRoom()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeFaculty:
		m.ResetFaculty()
		return nil
	case user.EdgeBranch:
		m.ResetBranch()
		return nil
	case user.EdgeBuilding:
		m.ResetBuilding()
		return nil
	case user.EdgeRoom:
		m.ResetRoom()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
