// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/moominzie/user-record/ent/bill"
	"github.com/moominzie/user-record/ent/billingstatus"
	"github.com/moominzie/user-record/ent/branch"
	"github.com/moominzie/user-record/ent/building"
	"github.com/moominzie/user-record/ent/device"
	"github.com/moominzie/user-record/ent/employee"
	"github.com/moominzie/user-record/ent/faculty"
	"github.com/moominzie/user-record/ent/part"
	"github.com/moominzie/user-record/ent/partorder"
	"github.com/moominzie/user-record/ent/repairinvoice"
	"github.com/moominzie/user-record/ent/returninvoice"
	"github.com/moominzie/user-record/ent/room"
	"github.com/moominzie/user-record/ent/statusr"
	"github.com/moominzie/user-record/ent/statust"
	"github.com/moominzie/user-record/ent/symptom"
	"github.com/moominzie/user-record/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBill          = "Bill"
	TypeBillingstatus = "Billingstatus"
	TypeBranch        = "Branch"
	TypeBuilding      = "Building"
	TypeDevice        = "Device"
	TypeEmployee      = "Employee"
	TypeFaculty       = "Faculty"
	TypePart          = "Part"
	TypePartorder     = "Partorder"
	TypeRepairInvoice = "RepairInvoice"
	TypeReturninvoice = "Returninvoice"
	TypeRoom          = "Room"
	TypeStatusR       = "StatusR"
	TypeStatust       = "Statust"
	TypeSymptom       = "Symptom"
	TypeUser          = "User"
)

// BillMutation represents an operation that mutate the Bills
// nodes in the graph.
type BillMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	price                 *int
	addprice              *int
	time                  *int
	addtime               *int
	clearedFields         map[string]struct{}
	_Repairinvoice        *int
	cleared_Repairinvoice bool
	_Employee             *int
	cleared_Employee      bool
	_Billingstatus        *int
	cleared_Billingstatus bool
	done                  bool
	oldValue              func(context.Context) (*Bill, error)
}

var _ ent.Mutation = (*BillMutation)(nil)

// billOption allows to manage the mutation configuration using functional options.
type billOption func(*BillMutation)

// newBillMutation creates new mutation for $n.Name.
func newBillMutation(c config, op Op, opts ...billOption) *BillMutation {
	m := &BillMutation{
		config:        c,
		op:            op,
		typ:           TypeBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillID sets the id field of the mutation.
func withBillID(id int) billOption {
	return func(m *BillMutation) {
		var (
			err   error
			once  sync.Once
			value *Bill
		)
		m.oldValue = func(ctx context.Context) (*Bill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBill sets the old Bill of the mutation.
func withBill(node *Bill) billOption {
	return func(m *BillMutation) {
		m.oldValue = func(context.Context) (*Bill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrice sets the price field.
func (m *BillMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the price value in the mutation.
func (m *BillMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old price value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to price.
func (m *BillMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the price field in this mutation.
func (m *BillMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice reset all changes of the "price" field.
func (m *BillMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetTime sets the time field.
func (m *BillMutation) SetTime(i int) {
	m.time = &i
	m.addtime = nil
}

// Time returns the time value in the mutation.
func (m *BillMutation) Time() (r int, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old time value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// AddTime adds i to time.
func (m *BillMutation) AddTime(i int) {
	if m.addtime != nil {
		*m.addtime += i
	} else {
		m.addtime = &i
	}
}

// AddedTime returns the value that was added to the time field in this mutation.
func (m *BillMutation) AddedTime() (r int, exists bool) {
	v := m.addtime
	if v == nil {
		return
	}
	return *v, true
}

// ResetTime reset all changes of the "time" field.
func (m *BillMutation) ResetTime() {
	m.time = nil
	m.addtime = nil
}

// SetRepairinvoiceID sets the Repairinvoice edge to RepairInvoice by id.
func (m *BillMutation) SetRepairinvoiceID(id int) {
	m._Repairinvoice = &id
}

// ClearRepairinvoice clears the Repairinvoice edge to RepairInvoice.
func (m *BillMutation) ClearRepairinvoice() {
	m.cleared_Repairinvoice = true
}

// RepairinvoiceCleared returns if the edge Repairinvoice was cleared.
func (m *BillMutation) RepairinvoiceCleared() bool {
	return m.cleared_Repairinvoice
}

// RepairinvoiceID returns the Repairinvoice id in the mutation.
func (m *BillMutation) RepairinvoiceID() (id int, exists bool) {
	if m._Repairinvoice != nil {
		return *m._Repairinvoice, true
	}
	return
}

// RepairinvoiceIDs returns the Repairinvoice ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RepairinvoiceID instead. It exists only for internal usage by the builders.
func (m *BillMutation) RepairinvoiceIDs() (ids []int) {
	if id := m._Repairinvoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepairinvoice reset all changes of the "Repairinvoice" edge.
func (m *BillMutation) ResetRepairinvoice() {
	m._Repairinvoice = nil
	m.cleared_Repairinvoice = false
}

// SetEmployeeID sets the Employee edge to Employee by id.
func (m *BillMutation) SetEmployeeID(id int) {
	m._Employee = &id
}

// ClearEmployee clears the Employee edge to Employee.
func (m *BillMutation) ClearEmployee() {
	m.cleared_Employee = true
}

// EmployeeCleared returns if the edge Employee was cleared.
func (m *BillMutation) EmployeeCleared() bool {
	return m.cleared_Employee
}

// EmployeeID returns the Employee id in the mutation.
func (m *BillMutation) EmployeeID() (id int, exists bool) {
	if m._Employee != nil {
		return *m._Employee, true
	}
	return
}

// EmployeeIDs returns the Employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *BillMutation) EmployeeIDs() (ids []int) {
	if id := m._Employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "Employee" edge.
func (m *BillMutation) ResetEmployee() {
	m._Employee = nil
	m.cleared_Employee = false
}

// SetBillingstatusID sets the Billingstatus edge to Billingstatus by id.
func (m *BillMutation) SetBillingstatusID(id int) {
	m._Billingstatus = &id
}

// ClearBillingstatus clears the Billingstatus edge to Billingstatus.
func (m *BillMutation) ClearBillingstatus() {
	m.cleared_Billingstatus = true
}

// BillingstatusCleared returns if the edge Billingstatus was cleared.
func (m *BillMutation) BillingstatusCleared() bool {
	return m.cleared_Billingstatus
}

// BillingstatusID returns the Billingstatus id in the mutation.
func (m *BillMutation) BillingstatusID() (id int, exists bool) {
	if m._Billingstatus != nil {
		return *m._Billingstatus, true
	}
	return
}

// BillingstatusIDs returns the Billingstatus ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BillingstatusID instead. It exists only for internal usage by the builders.
func (m *BillMutation) BillingstatusIDs() (ids []int) {
	if id := m._Billingstatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingstatus reset all changes of the "Billingstatus" edge.
func (m *BillMutation) ResetBillingstatus() {
	m._Billingstatus = nil
	m.cleared_Billingstatus = false
}

// Op returns the operation name.
func (m *BillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bill).
func (m *BillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.price != nil {
		fields = append(fields, bill.FieldPrice)
	}
	if m.time != nil {
		fields = append(fields, bill.FieldTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldPrice:
		return m.Price()
	case bill.FieldTime:
		return m.Time()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bill.FieldPrice:
		return m.OldPrice(ctx)
	case bill.FieldTime:
		return m.OldTime(ctx)
	}
	return nil, fmt.Errorf("unknown Bill field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bill.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case bill.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, bill.FieldPrice)
	}
	if m.addtime != nil {
		fields = append(fields, bill.FieldTime)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldPrice:
		return m.AddedPrice()
	case bill.FieldTime:
		return m.AddedTime()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bill.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case bill.FieldTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTime(v)
		return nil
	}
	return fmt.Errorf("unknown Bill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bill nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillMutation) ResetField(name string) error {
	switch name {
	case bill.FieldPrice:
		m.ResetPrice()
		return nil
	case bill.FieldTime:
		m.ResetTime()
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Repairinvoice != nil {
		edges = append(edges, bill.EdgeRepairinvoice)
	}
	if m._Employee != nil {
		edges = append(edges, bill.EdgeEmployee)
	}
	if m._Billingstatus != nil {
		edges = append(edges, bill.EdgeBillingstatus)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bill.EdgeRepairinvoice:
		if id := m._Repairinvoice; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeEmployee:
		if id := m._Employee; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeBillingstatus:
		if id := m._Billingstatus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Repairinvoice {
		edges = append(edges, bill.EdgeRepairinvoice)
	}
	if m.cleared_Employee {
		edges = append(edges, bill.EdgeEmployee)
	}
	if m.cleared_Billingstatus {
		edges = append(edges, bill.EdgeBillingstatus)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillMutation) EdgeCleared(name string) bool {
	switch name {
	case bill.EdgeRepairinvoice:
		return m.cleared_Repairinvoice
	case bill.EdgeEmployee:
		return m.cleared_Employee
	case bill.EdgeBillingstatus:
		return m.cleared_Billingstatus
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillMutation) ClearEdge(name string) error {
	switch name {
	case bill.EdgeRepairinvoice:
		m.ClearRepairinvoice()
		return nil
	case bill.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case bill.EdgeBillingstatus:
		m.ClearBillingstatus()
		return nil
	}
	return fmt.Errorf("unknown Bill unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillMutation) ResetEdge(name string) error {
	switch name {
	case bill.EdgeRepairinvoice:
		m.ResetRepairinvoice()
		return nil
	case bill.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case bill.EdgeBillingstatus:
		m.ResetBillingstatus()
		return nil
	}
	return fmt.Errorf("unknown Bill edge %s", name)
}

// BillingstatusMutation represents an operation that mutate the Billingstatuses
// nodes in the graph.
type BillingstatusMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	billingstatusname     *string
	clearedFields         map[string]struct{}
	billingstatuss        map[int]struct{}
	removedbillingstatuss map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*Billingstatus, error)
}

var _ ent.Mutation = (*BillingstatusMutation)(nil)

// billingstatusOption allows to manage the mutation configuration using functional options.
type billingstatusOption func(*BillingstatusMutation)

// newBillingstatusMutation creates new mutation for $n.Name.
func newBillingstatusMutation(c config, op Op, opts ...billingstatusOption) *BillingstatusMutation {
	m := &BillingstatusMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingstatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingstatusID sets the id field of the mutation.
func withBillingstatusID(id int) billingstatusOption {
	return func(m *BillingstatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Billingstatus
		)
		m.oldValue = func(ctx context.Context) (*Billingstatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Billingstatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingstatus sets the old Billingstatus of the mutation.
func withBillingstatus(node *Billingstatus) billingstatusOption {
	return func(m *BillingstatusMutation) {
		m.oldValue = func(context.Context) (*Billingstatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingstatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingstatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillingstatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBillingstatusname sets the billingstatusname field.
func (m *BillingstatusMutation) SetBillingstatusname(s string) {
	m.billingstatusname = &s
}

// Billingstatusname returns the billingstatusname value in the mutation.
func (m *BillingstatusMutation) Billingstatusname() (r string, exists bool) {
	v := m.billingstatusname
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingstatusname returns the old billingstatusname value of the Billingstatus.
// If the Billingstatus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillingstatusMutation) OldBillingstatusname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBillingstatusname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBillingstatusname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingstatusname: %w", err)
	}
	return oldValue.Billingstatusname, nil
}

// ResetBillingstatusname reset all changes of the "billingstatusname" field.
func (m *BillingstatusMutation) ResetBillingstatusname() {
	m.billingstatusname = nil
}

// AddBillingstatusIDs adds the billingstatuss edge to Bill by ids.
func (m *BillingstatusMutation) AddBillingstatusIDs(ids ...int) {
	if m.billingstatuss == nil {
		m.billingstatuss = make(map[int]struct{})
	}
	for i := range ids {
		m.billingstatuss[ids[i]] = struct{}{}
	}
}

// RemoveBillingstatusIDs removes the billingstatuss edge to Bill by ids.
func (m *BillingstatusMutation) RemoveBillingstatusIDs(ids ...int) {
	if m.removedbillingstatuss == nil {
		m.removedbillingstatuss = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbillingstatuss[ids[i]] = struct{}{}
	}
}

// RemovedBillingstatuss returns the removed ids of billingstatuss.
func (m *BillingstatusMutation) RemovedBillingstatussIDs() (ids []int) {
	for id := range m.removedbillingstatuss {
		ids = append(ids, id)
	}
	return
}

// BillingstatussIDs returns the billingstatuss ids in the mutation.
func (m *BillingstatusMutation) BillingstatussIDs() (ids []int) {
	for id := range m.billingstatuss {
		ids = append(ids, id)
	}
	return
}

// ResetBillingstatuss reset all changes of the "billingstatuss" edge.
func (m *BillingstatusMutation) ResetBillingstatuss() {
	m.billingstatuss = nil
	m.removedbillingstatuss = nil
}

// Op returns the operation name.
func (m *BillingstatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Billingstatus).
func (m *BillingstatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillingstatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.billingstatusname != nil {
		fields = append(fields, billingstatus.FieldBillingstatusname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillingstatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingstatus.FieldBillingstatusname:
		return m.Billingstatusname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillingstatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingstatus.FieldBillingstatusname:
		return m.OldBillingstatusname(ctx)
	}
	return nil, fmt.Errorf("unknown Billingstatus field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillingstatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingstatus.FieldBillingstatusname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingstatusname(v)
		return nil
	}
	return fmt.Errorf("unknown Billingstatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillingstatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillingstatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillingstatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Billingstatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillingstatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillingstatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingstatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Billingstatus nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillingstatusMutation) ResetField(name string) error {
	switch name {
	case billingstatus.FieldBillingstatusname:
		m.ResetBillingstatusname()
		return nil
	}
	return fmt.Errorf("unknown Billingstatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillingstatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.billingstatuss != nil {
		edges = append(edges, billingstatus.EdgeBillingstatuss)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillingstatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingstatus.EdgeBillingstatuss:
		ids := make([]ent.Value, 0, len(m.billingstatuss))
		for id := range m.billingstatuss {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillingstatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbillingstatuss != nil {
		edges = append(edges, billingstatus.EdgeBillingstatuss)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillingstatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billingstatus.EdgeBillingstatuss:
		ids := make([]ent.Value, 0, len(m.removedbillingstatuss))
		for id := range m.removedbillingstatuss {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillingstatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillingstatusMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillingstatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Billingstatus unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillingstatusMutation) ResetEdge(name string) error {
	switch name {
	case billingstatus.EdgeBillingstatuss:
		m.ResetBillingstatuss()
		return nil
	}
	return fmt.Errorf("unknown Billingstatus edge %s", name)
}

// BranchMutation represents an operation that mutate the Branches
// nodes in the graph.
type BranchMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	brname                   *string
	clearedFields            map[string]struct{}
	faculty                  *int
	clearedfaculty           bool
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Branch, error)
}

var _ ent.Mutation = (*BranchMutation)(nil)

// branchOption allows to manage the mutation configuration using functional options.
type branchOption func(*BranchMutation)

// newBranchMutation creates new mutation for $n.Name.
func newBranchMutation(c config, op Op, opts ...branchOption) *BranchMutation {
	m := &BranchMutation{
		config:        c,
		op:            op,
		typ:           TypeBranch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBranchID sets the id field of the mutation.
func withBranchID(id int) branchOption {
	return func(m *BranchMutation) {
		var (
			err   error
			once  sync.Once
			value *Branch
		)
		m.oldValue = func(ctx context.Context) (*Branch, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Branch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBranch sets the old Branch of the mutation.
func withBranch(node *Branch) branchOption {
	return func(m *BranchMutation) {
		m.oldValue = func(context.Context) (*Branch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BranchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BranchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BranchMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBrname sets the brname field.
func (m *BranchMutation) SetBrname(s string) {
	m.brname = &s
}

// Brname returns the brname value in the mutation.
func (m *BranchMutation) Brname() (r string, exists bool) {
	v := m.brname
	if v == nil {
		return
	}
	return *v, true
}

// OldBrname returns the old brname value of the Branch.
// If the Branch object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BranchMutation) OldBrname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBrname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBrname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrname: %w", err)
	}
	return oldValue.Brname, nil
}

// ResetBrname reset all changes of the "brname" field.
func (m *BranchMutation) ResetBrname() {
	m.brname = nil
}

// SetFacultyID sets the faculty edge to Faculty by id.
func (m *BranchMutation) SetFacultyID(id int) {
	m.faculty = &id
}

// ClearFaculty clears the faculty edge to Faculty.
func (m *BranchMutation) ClearFaculty() {
	m.clearedfaculty = true
}

// FacultyCleared returns if the edge faculty was cleared.
func (m *BranchMutation) FacultyCleared() bool {
	return m.clearedfaculty
}

// FacultyID returns the faculty id in the mutation.
func (m *BranchMutation) FacultyID() (id int, exists bool) {
	if m.faculty != nil {
		return *m.faculty, true
	}
	return
}

// FacultyIDs returns the faculty ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FacultyID instead. It exists only for internal usage by the builders.
func (m *BranchMutation) FacultyIDs() (ids []int) {
	if id := m.faculty; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFaculty reset all changes of the "faculty" edge.
func (m *BranchMutation) ResetFaculty() {
	m.faculty = nil
	m.clearedfaculty = false
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *BranchMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *BranchMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *BranchMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *BranchMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *BranchMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *BranchMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Branch).
func (m *BranchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BranchMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.brname != nil {
		fields = append(fields, branch.FieldBrname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BranchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case branch.FieldBrname:
		return m.Brname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BranchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case branch.FieldBrname:
		return m.OldBrname(ctx)
	}
	return nil, fmt.Errorf("unknown Branch field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BranchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case branch.FieldBrname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrname(v)
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BranchMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BranchMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BranchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Branch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BranchMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BranchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BranchMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Branch nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BranchMutation) ResetField(name string) error {
	switch name {
	case branch.FieldBrname:
		m.ResetBrname()
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BranchMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.faculty != nil {
		edges = append(edges, branch.EdgeFaculty)
	}
	if m.user_informations != nil {
		edges = append(edges, branch.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BranchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeFaculty:
		if id := m.faculty; id != nil {
			return []ent.Value{*id}
		}
	case branch.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BranchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_informations != nil {
		edges = append(edges, branch.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BranchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BranchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfaculty {
		edges = append(edges, branch.EdgeFaculty)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BranchMutation) EdgeCleared(name string) bool {
	switch name {
	case branch.EdgeFaculty:
		return m.clearedfaculty
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BranchMutation) ClearEdge(name string) error {
	switch name {
	case branch.EdgeFaculty:
		m.ClearFaculty()
		return nil
	}
	return fmt.Errorf("unknown Branch unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BranchMutation) ResetEdge(name string) error {
	switch name {
	case branch.EdgeFaculty:
		m.ResetFaculty()
		return nil
	case branch.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Branch edge %s", name)
}

// BuildingMutation represents an operation that mutate the Buildings
// nodes in the graph.
type BuildingMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	buname                   *string
	clearedFields            map[string]struct{}
	rooms                    map[int]struct{}
	removedrooms             map[int]struct{}
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Building, error)
}

var _ ent.Mutation = (*BuildingMutation)(nil)

// buildingOption allows to manage the mutation configuration using functional options.
type buildingOption func(*BuildingMutation)

// newBuildingMutation creates new mutation for $n.Name.
func newBuildingMutation(c config, op Op, opts ...buildingOption) *BuildingMutation {
	m := &BuildingMutation{
		config:        c,
		op:            op,
		typ:           TypeBuilding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildingID sets the id field of the mutation.
func withBuildingID(id int) buildingOption {
	return func(m *BuildingMutation) {
		var (
			err   error
			once  sync.Once
			value *Building
		)
		m.oldValue = func(ctx context.Context) (*Building, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Building.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuilding sets the old Building of the mutation.
func withBuilding(node *Building) buildingOption {
	return func(m *BuildingMutation) {
		m.oldValue = func(context.Context) (*Building, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BuildingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBuname sets the buname field.
func (m *BuildingMutation) SetBuname(s string) {
	m.buname = &s
}

// Buname returns the buname value in the mutation.
func (m *BuildingMutation) Buname() (r string, exists bool) {
	v := m.buname
	if v == nil {
		return
	}
	return *v, true
}

// OldBuname returns the old buname value of the Building.
// If the Building object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BuildingMutation) OldBuname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBuname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBuname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuname: %w", err)
	}
	return oldValue.Buname, nil
}

// ResetBuname reset all changes of the "buname" field.
func (m *BuildingMutation) ResetBuname() {
	m.buname = nil
}

// AddRoomIDs adds the rooms edge to Room by ids.
func (m *BuildingMutation) AddRoomIDs(ids ...int) {
	if m.rooms == nil {
		m.rooms = make(map[int]struct{})
	}
	for i := range ids {
		m.rooms[ids[i]] = struct{}{}
	}
}

// RemoveRoomIDs removes the rooms edge to Room by ids.
func (m *BuildingMutation) RemoveRoomIDs(ids ...int) {
	if m.removedrooms == nil {
		m.removedrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrooms[ids[i]] = struct{}{}
	}
}

// RemovedRooms returns the removed ids of rooms.
func (m *BuildingMutation) RemovedRoomsIDs() (ids []int) {
	for id := range m.removedrooms {
		ids = append(ids, id)
	}
	return
}

// RoomsIDs returns the rooms ids in the mutation.
func (m *BuildingMutation) RoomsIDs() (ids []int) {
	for id := range m.rooms {
		ids = append(ids, id)
	}
	return
}

// ResetRooms reset all changes of the "rooms" edge.
func (m *BuildingMutation) ResetRooms() {
	m.rooms = nil
	m.removedrooms = nil
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *BuildingMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *BuildingMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *BuildingMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *BuildingMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *BuildingMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *BuildingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Building).
func (m *BuildingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BuildingMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.buname != nil {
		fields = append(fields, building.FieldBuname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BuildingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case building.FieldBuname:
		return m.Buname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BuildingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case building.FieldBuname:
		return m.OldBuname(ctx)
	}
	return nil, fmt.Errorf("unknown Building field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BuildingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case building.FieldBuname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuname(v)
		return nil
	}
	return fmt.Errorf("unknown Building field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BuildingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BuildingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BuildingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Building numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BuildingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BuildingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Building nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BuildingMutation) ResetField(name string) error {
	switch name {
	case building.FieldBuname:
		m.ResetBuname()
		return nil
	}
	return fmt.Errorf("unknown Building field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BuildingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.rooms != nil {
		edges = append(edges, building.EdgeRooms)
	}
	if m.user_informations != nil {
		edges = append(edges, building.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BuildingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case building.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.rooms))
		for id := range m.rooms {
			ids = append(ids, id)
		}
		return ids
	case building.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BuildingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrooms != nil {
		edges = append(edges, building.EdgeRooms)
	}
	if m.removeduser_informations != nil {
		edges = append(edges, building.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BuildingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case building.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.removedrooms))
		for id := range m.removedrooms {
			ids = append(ids, id)
		}
		return ids
	case building.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BuildingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BuildingMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BuildingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Building unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BuildingMutation) ResetEdge(name string) error {
	switch name {
	case building.EdgeRooms:
		m.ResetRooms()
		return nil
	case building.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Building edge %s", name)
}

// DeviceMutation represents an operation that mutate the Devices
// nodes in the graph.
type DeviceMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Dname                    *string
	clearedFields             map[string]struct{}
	repair_information        map[int]struct{}
	removedrepair_information map[int]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Device, error)
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows to manage the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for $n.Name.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the id field of the mutation.
func withDeviceID(id int) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDname sets the Dname field.
func (m *DeviceMutation) SetDname(s string) {
	m._Dname = &s
}

// Dname returns the Dname value in the mutation.
func (m *DeviceMutation) Dname() (r string, exists bool) {
	v := m._Dname
	if v == nil {
		return
	}
	return *v, true
}

// OldDname returns the old Dname value of the Device.
// If the Device object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DeviceMutation) OldDname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDname: %w", err)
	}
	return oldValue.Dname, nil
}

// ResetDname reset all changes of the "Dname" field.
func (m *DeviceMutation) ResetDname() {
	m._Dname = nil
}

// AddRepairInformationIDs adds the repair_information edge to RepairInvoice by ids.
func (m *DeviceMutation) AddRepairInformationIDs(ids ...int) {
	if m.repair_information == nil {
		m.repair_information = make(map[int]struct{})
	}
	for i := range ids {
		m.repair_information[ids[i]] = struct{}{}
	}
}

// RemoveRepairInformationIDs removes the repair_information edge to RepairInvoice by ids.
func (m *DeviceMutation) RemoveRepairInformationIDs(ids ...int) {
	if m.removedrepair_information == nil {
		m.removedrepair_information = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrepair_information[ids[i]] = struct{}{}
	}
}

// RemovedRepairInformation returns the removed ids of repair_information.
func (m *DeviceMutation) RemovedRepairInformationIDs() (ids []int) {
	for id := range m.removedrepair_information {
		ids = append(ids, id)
	}
	return
}

// RepairInformationIDs returns the repair_information ids in the mutation.
func (m *DeviceMutation) RepairInformationIDs() (ids []int) {
	for id := range m.repair_information {
		ids = append(ids, id)
	}
	return
}

// ResetRepairInformation reset all changes of the "repair_information" edge.
func (m *DeviceMutation) ResetRepairInformation() {
	m.repair_information = nil
	m.removedrepair_information = nil
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Dname != nil {
		fields = append(fields, device.FieldDname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldDname:
		return m.Dname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldDname:
		return m.OldDname(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldDname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDname(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DeviceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldDname:
		m.ResetDname()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repair_information != nil {
		edges = append(edges, device.EdgeRepairInformation)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeRepairInformation:
		ids := make([]ent.Value, 0, len(m.repair_information))
		for id := range m.repair_information {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrepair_information != nil {
		edges = append(edges, device.EdgeRepairInformation)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeRepairInformation:
		ids := make([]ent.Value, 0, len(m.removedrepair_information))
		for id := range m.removedrepair_information {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeRepairInformation:
		m.ResetRepairInformation()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	employeename        *string
	employeeemail       *string
	password            *string
	clearedFields       map[string]struct{}
	employees           map[int]struct{}
	removedemployees    map[int]struct{}
	employeebill        map[int]struct{}
	removedemployeebill map[int]struct{}
	employeepart        map[int]struct{}
	removedemployeepart map[int]struct{}
	done                bool
	oldValue            func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmployeename sets the employeename field.
func (m *EmployeeMutation) SetEmployeename(s string) {
	m.employeename = &s
}

// Employeename returns the employeename value in the mutation.
func (m *EmployeeMutation) Employeename() (r string, exists bool) {
	v := m.employeename
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeename returns the old employeename value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeename: %w", err)
	}
	return oldValue.Employeename, nil
}

// ResetEmployeename reset all changes of the "employeename" field.
func (m *EmployeeMutation) ResetEmployeename() {
	m.employeename = nil
}

// SetEmployeeemail sets the employeeemail field.
func (m *EmployeeMutation) SetEmployeeemail(s string) {
	m.employeeemail = &s
}

// Employeeemail returns the employeeemail value in the mutation.
func (m *EmployeeMutation) Employeeemail() (r string, exists bool) {
	v := m.employeeemail
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeemail returns the old employeeemail value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeeemail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeeemail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeeemail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeemail: %w", err)
	}
	return oldValue.Employeeemail, nil
}

// ResetEmployeeemail reset all changes of the "employeeemail" field.
func (m *EmployeeMutation) ResetEmployeeemail() {
	m.employeeemail = nil
}

// SetPassword sets the password field.
func (m *EmployeeMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *EmployeeMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *EmployeeMutation) ResetPassword() {
	m.password = nil
}

// AddEmployeeIDs adds the employees edge to Returninvoice by ids.
func (m *EmployeeMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// RemoveEmployeeIDs removes the employees edge to Returninvoice by ids.
func (m *EmployeeMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed ids of employees.
func (m *EmployeeMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the employees ids in the mutation.
func (m *EmployeeMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees reset all changes of the "employees" edge.
func (m *EmployeeMutation) ResetEmployees() {
	m.employees = nil
	m.removedemployees = nil
}

// AddEmployeebillIDs adds the employeebill edge to Bill by ids.
func (m *EmployeeMutation) AddEmployeebillIDs(ids ...int) {
	if m.employeebill == nil {
		m.employeebill = make(map[int]struct{})
	}
	for i := range ids {
		m.employeebill[ids[i]] = struct{}{}
	}
}

// RemoveEmployeebillIDs removes the employeebill edge to Bill by ids.
func (m *EmployeeMutation) RemoveEmployeebillIDs(ids ...int) {
	if m.removedemployeebill == nil {
		m.removedemployeebill = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployeebill[ids[i]] = struct{}{}
	}
}

// RemovedEmployeebill returns the removed ids of employeebill.
func (m *EmployeeMutation) RemovedEmployeebillIDs() (ids []int) {
	for id := range m.removedemployeebill {
		ids = append(ids, id)
	}
	return
}

// EmployeebillIDs returns the employeebill ids in the mutation.
func (m *EmployeeMutation) EmployeebillIDs() (ids []int) {
	for id := range m.employeebill {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeebill reset all changes of the "employeebill" edge.
func (m *EmployeeMutation) ResetEmployeebill() {
	m.employeebill = nil
	m.removedemployeebill = nil
}

// AddEmployeepartIDs adds the employeepart edge to Partorder by ids.
func (m *EmployeeMutation) AddEmployeepartIDs(ids ...int) {
	if m.employeepart == nil {
		m.employeepart = make(map[int]struct{})
	}
	for i := range ids {
		m.employeepart[ids[i]] = struct{}{}
	}
}

// RemoveEmployeepartIDs removes the employeepart edge to Partorder by ids.
func (m *EmployeeMutation) RemoveEmployeepartIDs(ids ...int) {
	if m.removedemployeepart == nil {
		m.removedemployeepart = make(map[int]struct{})
	}
	for i := range ids {
		m.removedemployeepart[ids[i]] = struct{}{}
	}
}

// RemovedEmployeepart returns the removed ids of employeepart.
func (m *EmployeeMutation) RemovedEmployeepartIDs() (ids []int) {
	for id := range m.removedemployeepart {
		ids = append(ids, id)
	}
	return
}

// EmployeepartIDs returns the employeepart ids in the mutation.
func (m *EmployeeMutation) EmployeepartIDs() (ids []int) {
	for id := range m.employeepart {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeepart reset all changes of the "employeepart" edge.
func (m *EmployeeMutation) ResetEmployeepart() {
	m.employeepart = nil
	m.removedemployeepart = nil
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.employeename != nil {
		fields = append(fields, employee.FieldEmployeename)
	}
	if m.employeeemail != nil {
		fields = append(fields, employee.FieldEmployeeemail)
	}
	if m.password != nil {
		fields = append(fields, employee.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldEmployeename:
		return m.Employeename()
	case employee.FieldEmployeeemail:
		return m.Employeeemail()
	case employee.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldEmployeename:
		return m.OldEmployeename(ctx)
	case employee.FieldEmployeeemail:
		return m.OldEmployeeemail(ctx)
	case employee.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldEmployeename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeename(v)
		return nil
	case employee.FieldEmployeeemail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeemail(v)
		return nil
	case employee.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldEmployeename:
		m.ResetEmployeename()
		return nil
	case employee.FieldEmployeeemail:
		m.ResetEmployeeemail()
		return nil
	case employee.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.employees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	if m.employeebill != nil {
		edges = append(edges, employee.EdgeEmployeebill)
	}
	if m.employeepart != nil {
		edges = append(edges, employee.EdgeEmployeepart)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeEmployeebill:
		ids := make([]ent.Value, 0, len(m.employeebill))
		for id := range m.employeebill {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeEmployeepart:
		ids := make([]ent.Value, 0, len(m.employeepart))
		for id := range m.employeepart {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedemployees != nil {
		edges = append(edges, employee.EdgeEmployees)
	}
	if m.removedemployeebill != nil {
		edges = append(edges, employee.EdgeEmployeebill)
	}
	if m.removedemployeepart != nil {
		edges = append(edges, employee.EdgeEmployeepart)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeEmployeebill:
		ids := make([]ent.Value, 0, len(m.removedemployeebill))
		for id := range m.removedemployeebill {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeEmployeepart:
		ids := make([]ent.Value, 0, len(m.removedemployeepart))
		for id := range m.removedemployeepart {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case employee.EdgeEmployeebill:
		m.ResetEmployeebill()
		return nil
	case employee.EdgeEmployeepart:
		m.ResetEmployeepart()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// FacultyMutation represents an operation that mutate the Faculties
// nodes in the graph.
type FacultyMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	fname                    *string
	clearedFields            map[string]struct{}
	branchs                  map[int]struct{}
	removedbranchs           map[int]struct{}
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Faculty, error)
}

var _ ent.Mutation = (*FacultyMutation)(nil)

// facultyOption allows to manage the mutation configuration using functional options.
type facultyOption func(*FacultyMutation)

// newFacultyMutation creates new mutation for $n.Name.
func newFacultyMutation(c config, op Op, opts ...facultyOption) *FacultyMutation {
	m := &FacultyMutation{
		config:        c,
		op:            op,
		typ:           TypeFaculty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacultyID sets the id field of the mutation.
func withFacultyID(id int) facultyOption {
	return func(m *FacultyMutation) {
		var (
			err   error
			once  sync.Once
			value *Faculty
		)
		m.oldValue = func(ctx context.Context) (*Faculty, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Faculty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFaculty sets the old Faculty of the mutation.
func withFaculty(node *Faculty) facultyOption {
	return func(m *FacultyMutation) {
		m.oldValue = func(context.Context) (*Faculty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacultyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacultyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FacultyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFname sets the fname field.
func (m *FacultyMutation) SetFname(s string) {
	m.fname = &s
}

// Fname returns the fname value in the mutation.
func (m *FacultyMutation) Fname() (r string, exists bool) {
	v := m.fname
	if v == nil {
		return
	}
	return *v, true
}

// OldFname returns the old fname value of the Faculty.
// If the Faculty object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FacultyMutation) OldFname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFname: %w", err)
	}
	return oldValue.Fname, nil
}

// ResetFname reset all changes of the "fname" field.
func (m *FacultyMutation) ResetFname() {
	m.fname = nil
}

// AddBranchIDs adds the branchs edge to Branch by ids.
func (m *FacultyMutation) AddBranchIDs(ids ...int) {
	if m.branchs == nil {
		m.branchs = make(map[int]struct{})
	}
	for i := range ids {
		m.branchs[ids[i]] = struct{}{}
	}
}

// RemoveBranchIDs removes the branchs edge to Branch by ids.
func (m *FacultyMutation) RemoveBranchIDs(ids ...int) {
	if m.removedbranchs == nil {
		m.removedbranchs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedbranchs[ids[i]] = struct{}{}
	}
}

// RemovedBranchs returns the removed ids of branchs.
func (m *FacultyMutation) RemovedBranchsIDs() (ids []int) {
	for id := range m.removedbranchs {
		ids = append(ids, id)
	}
	return
}

// BranchsIDs returns the branchs ids in the mutation.
func (m *FacultyMutation) BranchsIDs() (ids []int) {
	for id := range m.branchs {
		ids = append(ids, id)
	}
	return
}

// ResetBranchs reset all changes of the "branchs" edge.
func (m *FacultyMutation) ResetBranchs() {
	m.branchs = nil
	m.removedbranchs = nil
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *FacultyMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *FacultyMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *FacultyMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *FacultyMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *FacultyMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *FacultyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Faculty).
func (m *FacultyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FacultyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.fname != nil {
		fields = append(fields, faculty.FieldFname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FacultyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case faculty.FieldFname:
		return m.Fname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FacultyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case faculty.FieldFname:
		return m.OldFname(ctx)
	}
	return nil, fmt.Errorf("unknown Faculty field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacultyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case faculty.FieldFname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFname(v)
		return nil
	}
	return fmt.Errorf("unknown Faculty field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FacultyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FacultyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FacultyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Faculty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FacultyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FacultyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacultyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Faculty nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FacultyMutation) ResetField(name string) error {
	switch name {
	case faculty.FieldFname:
		m.ResetFname()
		return nil
	}
	return fmt.Errorf("unknown Faculty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FacultyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.branchs != nil {
		edges = append(edges, faculty.EdgeBranchs)
	}
	if m.user_informations != nil {
		edges = append(edges, faculty.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FacultyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case faculty.EdgeBranchs:
		ids := make([]ent.Value, 0, len(m.branchs))
		for id := range m.branchs {
			ids = append(ids, id)
		}
		return ids
	case faculty.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FacultyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbranchs != nil {
		edges = append(edges, faculty.EdgeBranchs)
	}
	if m.removeduser_informations != nil {
		edges = append(edges, faculty.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FacultyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case faculty.EdgeBranchs:
		ids := make([]ent.Value, 0, len(m.removedbranchs))
		for id := range m.removedbranchs {
			ids = append(ids, id)
		}
		return ids
	case faculty.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FacultyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FacultyMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FacultyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Faculty unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FacultyMutation) ResetEdge(name string) error {
	switch name {
	case faculty.EdgeBranchs:
		m.ResetBranchs()
		return nil
	case faculty.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Faculty edge %s", name)
}

// PartMutation represents an operation that mutate the Parts
// nodes in the graph.
type PartMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	_Pname                   *string
	clearedFields            map[string]struct{}
	part_informations        map[int]struct{}
	removedpart_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Part, error)
}

var _ ent.Mutation = (*PartMutation)(nil)

// partOption allows to manage the mutation configuration using functional options.
type partOption func(*PartMutation)

// newPartMutation creates new mutation for $n.Name.
func newPartMutation(c config, op Op, opts ...partOption) *PartMutation {
	m := &PartMutation{
		config:        c,
		op:            op,
		typ:           TypePart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartID sets the id field of the mutation.
func withPartID(id int) partOption {
	return func(m *PartMutation) {
		var (
			err   error
			once  sync.Once
			value *Part
		)
		m.oldValue = func(ctx context.Context) (*Part, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Part.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPart sets the old Part of the mutation.
func withPart(node *Part) partOption {
	return func(m *PartMutation) {
		m.oldValue = func(context.Context) (*Part, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PartMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPname sets the Pname field.
func (m *PartMutation) SetPname(s string) {
	m._Pname = &s
}

// Pname returns the Pname value in the mutation.
func (m *PartMutation) Pname() (r string, exists bool) {
	v := m._Pname
	if v == nil {
		return
	}
	return *v, true
}

// OldPname returns the old Pname value of the Part.
// If the Part object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PartMutation) OldPname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPname: %w", err)
	}
	return oldValue.Pname, nil
}

// ResetPname reset all changes of the "Pname" field.
func (m *PartMutation) ResetPname() {
	m._Pname = nil
}

// AddPartInformationIDs adds the part_informations edge to Partorder by ids.
func (m *PartMutation) AddPartInformationIDs(ids ...int) {
	if m.part_informations == nil {
		m.part_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.part_informations[ids[i]] = struct{}{}
	}
}

// RemovePartInformationIDs removes the part_informations edge to Partorder by ids.
func (m *PartMutation) RemovePartInformationIDs(ids ...int) {
	if m.removedpart_informations == nil {
		m.removedpart_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpart_informations[ids[i]] = struct{}{}
	}
}

// RemovedPartInformations returns the removed ids of part_informations.
func (m *PartMutation) RemovedPartInformationsIDs() (ids []int) {
	for id := range m.removedpart_informations {
		ids = append(ids, id)
	}
	return
}

// PartInformationsIDs returns the part_informations ids in the mutation.
func (m *PartMutation) PartInformationsIDs() (ids []int) {
	for id := range m.part_informations {
		ids = append(ids, id)
	}
	return
}

// ResetPartInformations reset all changes of the "part_informations" edge.
func (m *PartMutation) ResetPartInformations() {
	m.part_informations = nil
	m.removedpart_informations = nil
}

// Op returns the operation name.
func (m *PartMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Part).
func (m *PartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PartMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Pname != nil {
		fields = append(fields, part.FieldPname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PartMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case part.FieldPname:
		return m.Pname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case part.FieldPname:
		return m.OldPname(ctx)
	}
	return nil, fmt.Errorf("unknown Part field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PartMutation) SetField(name string, value ent.Value) error {
	switch name {
	case part.FieldPname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPname(v)
		return nil
	}
	return fmt.Errorf("unknown Part field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PartMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PartMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PartMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Part numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PartMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Part nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PartMutation) ResetField(name string) error {
	switch name {
	case part.FieldPname:
		m.ResetPname()
		return nil
	}
	return fmt.Errorf("unknown Part field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PartMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.part_informations != nil {
		edges = append(edges, part.EdgePartInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case part.EdgePartInformations:
		ids := make([]ent.Value, 0, len(m.part_informations))
		for id := range m.part_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpart_informations != nil {
		edges = append(edges, part.EdgePartInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PartMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case part.EdgePartInformations:
		ids := make([]ent.Value, 0, len(m.removedpart_informations))
		for id := range m.removedpart_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PartMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PartMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Part unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PartMutation) ResetEdge(name string) error {
	switch name {
	case part.EdgePartInformations:
		m.ResetPartInformations()
		return nil
	}
	return fmt.Errorf("unknown Part edge %s", name)
}

// PartorderMutation represents an operation that mutate the Partorders
// nodes in the graph.
type PartorderMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	clearedFields        map[string]struct{}
	repairinvoice        *int
	clearedrepairinvoice bool
	employee             *int
	clearedemployee      bool
	part                 *int
	clearedpart          bool
	done                 bool
	oldValue             func(context.Context) (*Partorder, error)
}

var _ ent.Mutation = (*PartorderMutation)(nil)

// partorderOption allows to manage the mutation configuration using functional options.
type partorderOption func(*PartorderMutation)

// newPartorderMutation creates new mutation for $n.Name.
func newPartorderMutation(c config, op Op, opts ...partorderOption) *PartorderMutation {
	m := &PartorderMutation{
		config:        c,
		op:            op,
		typ:           TypePartorder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartorderID sets the id field of the mutation.
func withPartorderID(id int) partorderOption {
	return func(m *PartorderMutation) {
		var (
			err   error
			once  sync.Once
			value *Partorder
		)
		m.oldValue = func(ctx context.Context) (*Partorder, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Partorder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartorder sets the old Partorder of the mutation.
func withPartorder(node *Partorder) partorderOption {
	return func(m *PartorderMutation) {
		m.oldValue = func(context.Context) (*Partorder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartorderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartorderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PartorderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRepairinvoiceID sets the repairinvoice edge to RepairInvoice by id.
func (m *PartorderMutation) SetRepairinvoiceID(id int) {
	m.repairinvoice = &id
}

// ClearRepairinvoice clears the repairinvoice edge to RepairInvoice.
func (m *PartorderMutation) ClearRepairinvoice() {
	m.clearedrepairinvoice = true
}

// RepairinvoiceCleared returns if the edge repairinvoice was cleared.
func (m *PartorderMutation) RepairinvoiceCleared() bool {
	return m.clearedrepairinvoice
}

// RepairinvoiceID returns the repairinvoice id in the mutation.
func (m *PartorderMutation) RepairinvoiceID() (id int, exists bool) {
	if m.repairinvoice != nil {
		return *m.repairinvoice, true
	}
	return
}

// RepairinvoiceIDs returns the repairinvoice ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RepairinvoiceID instead. It exists only for internal usage by the builders.
func (m *PartorderMutation) RepairinvoiceIDs() (ids []int) {
	if id := m.repairinvoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepairinvoice reset all changes of the "repairinvoice" edge.
func (m *PartorderMutation) ResetRepairinvoice() {
	m.repairinvoice = nil
	m.clearedrepairinvoice = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *PartorderMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *PartorderMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *PartorderMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *PartorderMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *PartorderMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *PartorderMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetPartID sets the part edge to Part by id.
func (m *PartorderMutation) SetPartID(id int) {
	m.part = &id
}

// ClearPart clears the part edge to Part.
func (m *PartorderMutation) ClearPart() {
	m.clearedpart = true
}

// PartCleared returns if the edge part was cleared.
func (m *PartorderMutation) PartCleared() bool {
	return m.clearedpart
}

// PartID returns the part id in the mutation.
func (m *PartorderMutation) PartID() (id int, exists bool) {
	if m.part != nil {
		return *m.part, true
	}
	return
}

// PartIDs returns the part ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PartID instead. It exists only for internal usage by the builders.
func (m *PartorderMutation) PartIDs() (ids []int) {
	if id := m.part; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPart reset all changes of the "part" edge.
func (m *PartorderMutation) ResetPart() {
	m.part = nil
	m.clearedpart = false
}

// Op returns the operation name.
func (m *PartorderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Partorder).
func (m *PartorderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PartorderMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PartorderMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PartorderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Partorder field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PartorderMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Partorder field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PartorderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PartorderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PartorderMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Partorder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PartorderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PartorderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartorderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Partorder nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PartorderMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Partorder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PartorderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.repairinvoice != nil {
		edges = append(edges, partorder.EdgeRepairinvoice)
	}
	if m.employee != nil {
		edges = append(edges, partorder.EdgeEmployee)
	}
	if m.part != nil {
		edges = append(edges, partorder.EdgePart)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PartorderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partorder.EdgeRepairinvoice:
		if id := m.repairinvoice; id != nil {
			return []ent.Value{*id}
		}
	case partorder.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case partorder.EdgePart:
		if id := m.part; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PartorderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PartorderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PartorderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrepairinvoice {
		edges = append(edges, partorder.EdgeRepairinvoice)
	}
	if m.clearedemployee {
		edges = append(edges, partorder.EdgeEmployee)
	}
	if m.clearedpart {
		edges = append(edges, partorder.EdgePart)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PartorderMutation) EdgeCleared(name string) bool {
	switch name {
	case partorder.EdgeRepairinvoice:
		return m.clearedrepairinvoice
	case partorder.EdgeEmployee:
		return m.clearedemployee
	case partorder.EdgePart:
		return m.clearedpart
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PartorderMutation) ClearEdge(name string) error {
	switch name {
	case partorder.EdgeRepairinvoice:
		m.ClearRepairinvoice()
		return nil
	case partorder.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case partorder.EdgePart:
		m.ClearPart()
		return nil
	}
	return fmt.Errorf("unknown Partorder unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PartorderMutation) ResetEdge(name string) error {
	switch name {
	case partorder.EdgeRepairinvoice:
		m.ResetRepairinvoice()
		return nil
	case partorder.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case partorder.EdgePart:
		m.ResetPart()
		return nil
	}
	return fmt.Errorf("unknown Partorder edge %s", name)
}

// RepairInvoiceMutation represents an operation that mutate the RepairInvoices
// nodes in the graph.
type RepairInvoiceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	_Rename                  *string
	clearedFields            map[string]struct{}
	device                   *int
	cleareddevice            bool
	status                   *int
	clearedstatus            bool
	symptom                  *int
	clearedsymptom           bool
	user                     *int
	cleareduser              bool
	returninvoice            *int
	clearedreturninvoice     bool
	bill                     *int
	clearedbill              bool
	part_informations        *int
	clearedpart_informations bool
	done                     bool
	oldValue                 func(context.Context) (*RepairInvoice, error)
}

var _ ent.Mutation = (*RepairInvoiceMutation)(nil)

// repairinvoiceOption allows to manage the mutation configuration using functional options.
type repairinvoiceOption func(*RepairInvoiceMutation)

// newRepairInvoiceMutation creates new mutation for $n.Name.
func newRepairInvoiceMutation(c config, op Op, opts ...repairinvoiceOption) *RepairInvoiceMutation {
	m := &RepairInvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeRepairInvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepairInvoiceID sets the id field of the mutation.
func withRepairInvoiceID(id int) repairinvoiceOption {
	return func(m *RepairInvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *RepairInvoice
		)
		m.oldValue = func(ctx context.Context) (*RepairInvoice, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RepairInvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepairInvoice sets the old RepairInvoice of the mutation.
func withRepairInvoice(node *RepairInvoice) repairinvoiceOption {
	return func(m *RepairInvoiceMutation) {
		m.oldValue = func(context.Context) (*RepairInvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepairInvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepairInvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RepairInvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRename sets the Rename field.
func (m *RepairInvoiceMutation) SetRename(s string) {
	m._Rename = &s
}

// Rename returns the Rename value in the mutation.
func (m *RepairInvoiceMutation) Rename() (r string, exists bool) {
	v := m._Rename
	if v == nil {
		return
	}
	return *v, true
}

// OldRename returns the old Rename value of the RepairInvoice.
// If the RepairInvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RepairInvoiceMutation) OldRename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRename is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRename: %w", err)
	}
	return oldValue.Rename, nil
}

// ResetRename reset all changes of the "Rename" field.
func (m *RepairInvoiceMutation) ResetRename() {
	m._Rename = nil
}

// SetDeviceID sets the device edge to Device by id.
func (m *RepairInvoiceMutation) SetDeviceID(id int) {
	m.device = &id
}

// ClearDevice clears the device edge to Device.
func (m *RepairInvoiceMutation) ClearDevice() {
	m.cleareddevice = true
}

// DeviceCleared returns if the edge device was cleared.
func (m *RepairInvoiceMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceID returns the device id in the mutation.
func (m *RepairInvoiceMutation) DeviceID() (id int, exists bool) {
	if m.device != nil {
		return *m.device, true
	}
	return
}

// DeviceIDs returns the device ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *RepairInvoiceMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice reset all changes of the "device" edge.
func (m *RepairInvoiceMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// SetStatusID sets the status edge to StatusR by id.
func (m *RepairInvoiceMutation) SetStatusID(id int) {
	m.status = &id
}

// ClearStatus clears the status edge to StatusR.
func (m *RepairInvoiceMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared returns if the edge status was cleared.
func (m *RepairInvoiceMutation) StatusCleared() bool {
	return m.clearedstatus
}

// StatusID returns the status id in the mutation.
func (m *RepairInvoiceMutation) StatusID() (id int, exists bool) {
	if m.status != nil {
		return *m.status, true
	}
	return
}

// StatusIDs returns the status ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *RepairInvoiceMutation) StatusIDs() (ids []int) {
	if id := m.status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus reset all changes of the "status" edge.
func (m *RepairInvoiceMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
}

// SetSymptomID sets the symptom edge to Symptom by id.
func (m *RepairInvoiceMutation) SetSymptomID(id int) {
	m.symptom = &id
}

// ClearSymptom clears the symptom edge to Symptom.
func (m *RepairInvoiceMutation) ClearSymptom() {
	m.clearedsymptom = true
}

// SymptomCleared returns if the edge symptom was cleared.
func (m *RepairInvoiceMutation) SymptomCleared() bool {
	return m.clearedsymptom
}

// SymptomID returns the symptom id in the mutation.
func (m *RepairInvoiceMutation) SymptomID() (id int, exists bool) {
	if m.symptom != nil {
		return *m.symptom, true
	}
	return
}

// SymptomIDs returns the symptom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SymptomID instead. It exists only for internal usage by the builders.
func (m *RepairInvoiceMutation) SymptomIDs() (ids []int) {
	if id := m.symptom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymptom reset all changes of the "symptom" edge.
func (m *RepairInvoiceMutation) ResetSymptom() {
	m.symptom = nil
	m.clearedsymptom = false
}

// SetUserID sets the user edge to User by id.
func (m *RepairInvoiceMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *RepairInvoiceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *RepairInvoiceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *RepairInvoiceMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RepairInvoiceMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *RepairInvoiceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetReturninvoiceID sets the returninvoice edge to Returninvoice by id.
func (m *RepairInvoiceMutation) SetReturninvoiceID(id int) {
	m.returninvoice = &id
}

// ClearReturninvoice clears the returninvoice edge to Returninvoice.
func (m *RepairInvoiceMutation) ClearReturninvoice() {
	m.clearedreturninvoice = true
}

// ReturninvoiceCleared returns if the edge returninvoice was cleared.
func (m *RepairInvoiceMutation) ReturninvoiceCleared() bool {
	return m.clearedreturninvoice
}

// ReturninvoiceID returns the returninvoice id in the mutation.
func (m *RepairInvoiceMutation) ReturninvoiceID() (id int, exists bool) {
	if m.returninvoice != nil {
		return *m.returninvoice, true
	}
	return
}

// ReturninvoiceIDs returns the returninvoice ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ReturninvoiceID instead. It exists only for internal usage by the builders.
func (m *RepairInvoiceMutation) ReturninvoiceIDs() (ids []int) {
	if id := m.returninvoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReturninvoice reset all changes of the "returninvoice" edge.
func (m *RepairInvoiceMutation) ResetReturninvoice() {
	m.returninvoice = nil
	m.clearedreturninvoice = false
}

// SetBillID sets the bill edge to Bill by id.
func (m *RepairInvoiceMutation) SetBillID(id int) {
	m.bill = &id
}

// ClearBill clears the bill edge to Bill.
func (m *RepairInvoiceMutation) ClearBill() {
	m.clearedbill = true
}

// BillCleared returns if the edge bill was cleared.
func (m *RepairInvoiceMutation) BillCleared() bool {
	return m.clearedbill
}

// BillID returns the bill id in the mutation.
func (m *RepairInvoiceMutation) BillID() (id int, exists bool) {
	if m.bill != nil {
		return *m.bill, true
	}
	return
}

// BillIDs returns the bill ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BillID instead. It exists only for internal usage by the builders.
func (m *RepairInvoiceMutation) BillIDs() (ids []int) {
	if id := m.bill; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBill reset all changes of the "bill" edge.
func (m *RepairInvoiceMutation) ResetBill() {
	m.bill = nil
	m.clearedbill = false
}

// SetPartInformationsID sets the part_informations edge to Partorder by id.
func (m *RepairInvoiceMutation) SetPartInformationsID(id int) {
	m.part_informations = &id
}

// ClearPartInformations clears the part_informations edge to Partorder.
func (m *RepairInvoiceMutation) ClearPartInformations() {
	m.clearedpart_informations = true
}

// PartInformationsCleared returns if the edge part_informations was cleared.
func (m *RepairInvoiceMutation) PartInformationsCleared() bool {
	return m.clearedpart_informations
}

// PartInformationsID returns the part_informations id in the mutation.
func (m *RepairInvoiceMutation) PartInformationsID() (id int, exists bool) {
	if m.part_informations != nil {
		return *m.part_informations, true
	}
	return
}

// PartInformationsIDs returns the part_informations ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PartInformationsID instead. It exists only for internal usage by the builders.
func (m *RepairInvoiceMutation) PartInformationsIDs() (ids []int) {
	if id := m.part_informations; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartInformations reset all changes of the "part_informations" edge.
func (m *RepairInvoiceMutation) ResetPartInformations() {
	m.part_informations = nil
	m.clearedpart_informations = false
}

// Op returns the operation name.
func (m *RepairInvoiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RepairInvoice).
func (m *RepairInvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RepairInvoiceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Rename != nil {
		fields = append(fields, repairinvoice.FieldRename)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RepairInvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repairinvoice.FieldRename:
		return m.Rename()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RepairInvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repairinvoice.FieldRename:
		return m.OldRename(ctx)
	}
	return nil, fmt.Errorf("unknown RepairInvoice field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairInvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repairinvoice.FieldRename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRename(v)
		return nil
	}
	return fmt.Errorf("unknown RepairInvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RepairInvoiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RepairInvoiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RepairInvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RepairInvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RepairInvoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RepairInvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepairInvoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RepairInvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RepairInvoiceMutation) ResetField(name string) error {
	switch name {
	case repairinvoice.FieldRename:
		m.ResetRename()
		return nil
	}
	return fmt.Errorf("unknown RepairInvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RepairInvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.device != nil {
		edges = append(edges, repairinvoice.EdgeDevice)
	}
	if m.status != nil {
		edges = append(edges, repairinvoice.EdgeStatus)
	}
	if m.symptom != nil {
		edges = append(edges, repairinvoice.EdgeSymptom)
	}
	if m.user != nil {
		edges = append(edges, repairinvoice.EdgeUser)
	}
	if m.returninvoice != nil {
		edges = append(edges, repairinvoice.EdgeReturninvoice)
	}
	if m.bill != nil {
		edges = append(edges, repairinvoice.EdgeBill)
	}
	if m.part_informations != nil {
		edges = append(edges, repairinvoice.EdgePartInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RepairInvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repairinvoice.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case repairinvoice.EdgeStatus:
		if id := m.status; id != nil {
			return []ent.Value{*id}
		}
	case repairinvoice.EdgeSymptom:
		if id := m.symptom; id != nil {
			return []ent.Value{*id}
		}
	case repairinvoice.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case repairinvoice.EdgeReturninvoice:
		if id := m.returninvoice; id != nil {
			return []ent.Value{*id}
		}
	case repairinvoice.EdgeBill:
		if id := m.bill; id != nil {
			return []ent.Value{*id}
		}
	case repairinvoice.EdgePartInformations:
		if id := m.part_informations; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RepairInvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RepairInvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RepairInvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleareddevice {
		edges = append(edges, repairinvoice.EdgeDevice)
	}
	if m.clearedstatus {
		edges = append(edges, repairinvoice.EdgeStatus)
	}
	if m.clearedsymptom {
		edges = append(edges, repairinvoice.EdgeSymptom)
	}
	if m.cleareduser {
		edges = append(edges, repairinvoice.EdgeUser)
	}
	if m.clearedreturninvoice {
		edges = append(edges, repairinvoice.EdgeReturninvoice)
	}
	if m.clearedbill {
		edges = append(edges, repairinvoice.EdgeBill)
	}
	if m.clearedpart_informations {
		edges = append(edges, repairinvoice.EdgePartInformations)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RepairInvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case repairinvoice.EdgeDevice:
		return m.cleareddevice
	case repairinvoice.EdgeStatus:
		return m.clearedstatus
	case repairinvoice.EdgeSymptom:
		return m.clearedsymptom
	case repairinvoice.EdgeUser:
		return m.cleareduser
	case repairinvoice.EdgeReturninvoice:
		return m.clearedreturninvoice
	case repairinvoice.EdgeBill:
		return m.clearedbill
	case repairinvoice.EdgePartInformations:
		return m.clearedpart_informations
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RepairInvoiceMutation) ClearEdge(name string) error {
	switch name {
	case repairinvoice.EdgeDevice:
		m.ClearDevice()
		return nil
	case repairinvoice.EdgeStatus:
		m.ClearStatus()
		return nil
	case repairinvoice.EdgeSymptom:
		m.ClearSymptom()
		return nil
	case repairinvoice.EdgeUser:
		m.ClearUser()
		return nil
	case repairinvoice.EdgeReturninvoice:
		m.ClearReturninvoice()
		return nil
	case repairinvoice.EdgeBill:
		m.ClearBill()
		return nil
	case repairinvoice.EdgePartInformations:
		m.ClearPartInformations()
		return nil
	}
	return fmt.Errorf("unknown RepairInvoice unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RepairInvoiceMutation) ResetEdge(name string) error {
	switch name {
	case repairinvoice.EdgeDevice:
		m.ResetDevice()
		return nil
	case repairinvoice.EdgeStatus:
		m.ResetStatus()
		return nil
	case repairinvoice.EdgeSymptom:
		m.ResetSymptom()
		return nil
	case repairinvoice.EdgeUser:
		m.ResetUser()
		return nil
	case repairinvoice.EdgeReturninvoice:
		m.ResetReturninvoice()
		return nil
	case repairinvoice.EdgeBill:
		m.ResetBill()
		return nil
	case repairinvoice.EdgePartInformations:
		m.ResetPartInformations()
		return nil
	}
	return fmt.Errorf("unknown RepairInvoice edge %s", name)
}

// ReturninvoiceMutation represents an operation that mutate the Returninvoices
// nodes in the graph.
type ReturninvoiceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	addedtime             *time.Time
	clearedFields         map[string]struct{}
	_Repairinvoice        *int
	cleared_Repairinvoice bool
	_Employee             *int
	cleared_Employee      bool
	_Statust              *int
	cleared_Statust       bool
	done                  bool
	oldValue              func(context.Context) (*Returninvoice, error)
}

var _ ent.Mutation = (*ReturninvoiceMutation)(nil)

// returninvoiceOption allows to manage the mutation configuration using functional options.
type returninvoiceOption func(*ReturninvoiceMutation)

// newReturninvoiceMutation creates new mutation for $n.Name.
func newReturninvoiceMutation(c config, op Op, opts ...returninvoiceOption) *ReturninvoiceMutation {
	m := &ReturninvoiceMutation{
		config:        c,
		op:            op,
		typ:           TypeReturninvoice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReturninvoiceID sets the id field of the mutation.
func withReturninvoiceID(id int) returninvoiceOption {
	return func(m *ReturninvoiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Returninvoice
		)
		m.oldValue = func(ctx context.Context) (*Returninvoice, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Returninvoice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReturninvoice sets the old Returninvoice of the mutation.
func withReturninvoice(node *Returninvoice) returninvoiceOption {
	return func(m *ReturninvoiceMutation) {
		m.oldValue = func(context.Context) (*Returninvoice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReturninvoiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReturninvoiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ReturninvoiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedtime sets the addedtime field.
func (m *ReturninvoiceMutation) SetAddedtime(t time.Time) {
	m.addedtime = &t
}

// Addedtime returns the addedtime value in the mutation.
func (m *ReturninvoiceMutation) Addedtime() (r time.Time, exists bool) {
	v := m.addedtime
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedtime returns the old addedtime value of the Returninvoice.
// If the Returninvoice object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReturninvoiceMutation) OldAddedtime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedtime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedtime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedtime: %w", err)
	}
	return oldValue.Addedtime, nil
}

// ResetAddedtime reset all changes of the "addedtime" field.
func (m *ReturninvoiceMutation) ResetAddedtime() {
	m.addedtime = nil
}

// SetRepairinvoiceID sets the Repairinvoice edge to RepairInvoice by id.
func (m *ReturninvoiceMutation) SetRepairinvoiceID(id int) {
	m._Repairinvoice = &id
}

// ClearRepairinvoice clears the Repairinvoice edge to RepairInvoice.
func (m *ReturninvoiceMutation) ClearRepairinvoice() {
	m.cleared_Repairinvoice = true
}

// RepairinvoiceCleared returns if the edge Repairinvoice was cleared.
func (m *ReturninvoiceMutation) RepairinvoiceCleared() bool {
	return m.cleared_Repairinvoice
}

// RepairinvoiceID returns the Repairinvoice id in the mutation.
func (m *ReturninvoiceMutation) RepairinvoiceID() (id int, exists bool) {
	if m._Repairinvoice != nil {
		return *m._Repairinvoice, true
	}
	return
}

// RepairinvoiceIDs returns the Repairinvoice ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RepairinvoiceID instead. It exists only for internal usage by the builders.
func (m *ReturninvoiceMutation) RepairinvoiceIDs() (ids []int) {
	if id := m._Repairinvoice; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepairinvoice reset all changes of the "Repairinvoice" edge.
func (m *ReturninvoiceMutation) ResetRepairinvoice() {
	m._Repairinvoice = nil
	m.cleared_Repairinvoice = false
}

// SetEmployeeID sets the Employee edge to Employee by id.
func (m *ReturninvoiceMutation) SetEmployeeID(id int) {
	m._Employee = &id
}

// ClearEmployee clears the Employee edge to Employee.
func (m *ReturninvoiceMutation) ClearEmployee() {
	m.cleared_Employee = true
}

// EmployeeCleared returns if the edge Employee was cleared.
func (m *ReturninvoiceMutation) EmployeeCleared() bool {
	return m.cleared_Employee
}

// EmployeeID returns the Employee id in the mutation.
func (m *ReturninvoiceMutation) EmployeeID() (id int, exists bool) {
	if m._Employee != nil {
		return *m._Employee, true
	}
	return
}

// EmployeeIDs returns the Employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *ReturninvoiceMutation) EmployeeIDs() (ids []int) {
	if id := m._Employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "Employee" edge.
func (m *ReturninvoiceMutation) ResetEmployee() {
	m._Employee = nil
	m.cleared_Employee = false
}

// SetStatustID sets the Statust edge to Statust by id.
func (m *ReturninvoiceMutation) SetStatustID(id int) {
	m._Statust = &id
}

// ClearStatust clears the Statust edge to Statust.
func (m *ReturninvoiceMutation) ClearStatust() {
	m.cleared_Statust = true
}

// StatustCleared returns if the edge Statust was cleared.
func (m *ReturninvoiceMutation) StatustCleared() bool {
	return m.cleared_Statust
}

// StatustID returns the Statust id in the mutation.
func (m *ReturninvoiceMutation) StatustID() (id int, exists bool) {
	if m._Statust != nil {
		return *m._Statust, true
	}
	return
}

// StatustIDs returns the Statust ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StatustID instead. It exists only for internal usage by the builders.
func (m *ReturninvoiceMutation) StatustIDs() (ids []int) {
	if id := m._Statust; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatust reset all changes of the "Statust" edge.
func (m *ReturninvoiceMutation) ResetStatust() {
	m._Statust = nil
	m.cleared_Statust = false
}

// Op returns the operation name.
func (m *ReturninvoiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Returninvoice).
func (m *ReturninvoiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ReturninvoiceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.addedtime != nil {
		fields = append(fields, returninvoice.FieldAddedtime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ReturninvoiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case returninvoice.FieldAddedtime:
		return m.Addedtime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ReturninvoiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case returninvoice.FieldAddedtime:
		return m.OldAddedtime(ctx)
	}
	return nil, fmt.Errorf("unknown Returninvoice field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReturninvoiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case returninvoice.FieldAddedtime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedtime(v)
		return nil
	}
	return fmt.Errorf("unknown Returninvoice field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ReturninvoiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ReturninvoiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReturninvoiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Returninvoice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ReturninvoiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ReturninvoiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReturninvoiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Returninvoice nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ReturninvoiceMutation) ResetField(name string) error {
	switch name {
	case returninvoice.FieldAddedtime:
		m.ResetAddedtime()
		return nil
	}
	return fmt.Errorf("unknown Returninvoice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ReturninvoiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Repairinvoice != nil {
		edges = append(edges, returninvoice.EdgeRepairinvoice)
	}
	if m._Employee != nil {
		edges = append(edges, returninvoice.EdgeEmployee)
	}
	if m._Statust != nil {
		edges = append(edges, returninvoice.EdgeStatust)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ReturninvoiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		if id := m._Repairinvoice; id != nil {
			return []ent.Value{*id}
		}
	case returninvoice.EdgeEmployee:
		if id := m._Employee; id != nil {
			return []ent.Value{*id}
		}
	case returninvoice.EdgeStatust:
		if id := m._Statust; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ReturninvoiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ReturninvoiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ReturninvoiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Repairinvoice {
		edges = append(edges, returninvoice.EdgeRepairinvoice)
	}
	if m.cleared_Employee {
		edges = append(edges, returninvoice.EdgeEmployee)
	}
	if m.cleared_Statust {
		edges = append(edges, returninvoice.EdgeStatust)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ReturninvoiceMutation) EdgeCleared(name string) bool {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		return m.cleared_Repairinvoice
	case returninvoice.EdgeEmployee:
		return m.cleared_Employee
	case returninvoice.EdgeStatust:
		return m.cleared_Statust
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ReturninvoiceMutation) ClearEdge(name string) error {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		m.ClearRepairinvoice()
		return nil
	case returninvoice.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case returninvoice.EdgeStatust:
		m.ClearStatust()
		return nil
	}
	return fmt.Errorf("unknown Returninvoice unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ReturninvoiceMutation) ResetEdge(name string) error {
	switch name {
	case returninvoice.EdgeRepairinvoice:
		m.ResetRepairinvoice()
		return nil
	case returninvoice.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case returninvoice.EdgeStatust:
		m.ResetStatust()
		return nil
	}
	return fmt.Errorf("unknown Returninvoice edge %s", name)
}

// RoomMutation represents an operation that mutate the Rooms
// nodes in the graph.
type RoomMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	rname                    *string
	clearedFields            map[string]struct{}
	building                 *int
	clearedbuilding          bool
	user_informations        map[int]struct{}
	removeduser_informations map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Room, error)
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows to manage the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for $n.Name.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the id field of the mutation.
func withRoomID(id int) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRname sets the rname field.
func (m *RoomMutation) SetRname(s string) {
	m.rname = &s
}

// Rname returns the rname value in the mutation.
func (m *RoomMutation) Rname() (r string, exists bool) {
	v := m.rname
	if v == nil {
		return
	}
	return *v, true
}

// OldRname returns the old rname value of the Room.
// If the Room object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomMutation) OldRname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRname: %w", err)
	}
	return oldValue.Rname, nil
}

// ResetRname reset all changes of the "rname" field.
func (m *RoomMutation) ResetRname() {
	m.rname = nil
}

// SetBuildingID sets the building edge to Building by id.
func (m *RoomMutation) SetBuildingID(id int) {
	m.building = &id
}

// ClearBuilding clears the building edge to Building.
func (m *RoomMutation) ClearBuilding() {
	m.clearedbuilding = true
}

// BuildingCleared returns if the edge building was cleared.
func (m *RoomMutation) BuildingCleared() bool {
	return m.clearedbuilding
}

// BuildingID returns the building id in the mutation.
func (m *RoomMutation) BuildingID() (id int, exists bool) {
	if m.building != nil {
		return *m.building, true
	}
	return
}

// BuildingIDs returns the building ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BuildingID instead. It exists only for internal usage by the builders.
func (m *RoomMutation) BuildingIDs() (ids []int) {
	if id := m.building; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuilding reset all changes of the "building" edge.
func (m *RoomMutation) ResetBuilding() {
	m.building = nil
	m.clearedbuilding = false
}

// AddUserInformationIDs adds the user_informations edge to User by ids.
func (m *RoomMutation) AddUserInformationIDs(ids ...int) {
	if m.user_informations == nil {
		m.user_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.user_informations[ids[i]] = struct{}{}
	}
}

// RemoveUserInformationIDs removes the user_informations edge to User by ids.
func (m *RoomMutation) RemoveUserInformationIDs(ids ...int) {
	if m.removeduser_informations == nil {
		m.removeduser_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_informations[ids[i]] = struct{}{}
	}
}

// RemovedUserInformations returns the removed ids of user_informations.
func (m *RoomMutation) RemovedUserInformationsIDs() (ids []int) {
	for id := range m.removeduser_informations {
		ids = append(ids, id)
	}
	return
}

// UserInformationsIDs returns the user_informations ids in the mutation.
func (m *RoomMutation) UserInformationsIDs() (ids []int) {
	for id := range m.user_informations {
		ids = append(ids, id)
	}
	return
}

// ResetUserInformations reset all changes of the "user_informations" edge.
func (m *RoomMutation) ResetUserInformations() {
	m.user_informations = nil
	m.removeduser_informations = nil
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.rname != nil {
		fields = append(fields, room.FieldRname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldRname:
		return m.Rname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldRname:
		return m.OldRname(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldRname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRname(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldRname:
		m.ResetRname()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.building != nil {
		edges = append(edges, room.EdgeBuilding)
	}
	if m.user_informations != nil {
		edges = append(edges, room.EdgeUserInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeBuilding:
		if id := m.building; id != nil {
			return []ent.Value{*id}
		}
	case room.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.user_informations))
		for id := range m.user_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_informations != nil {
		edges = append(edges, room.EdgeUserInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeUserInformations:
		ids := make([]ent.Value, 0, len(m.removeduser_informations))
		for id := range m.removeduser_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbuilding {
		edges = append(edges, room.EdgeBuilding)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	case room.EdgeBuilding:
		return m.clearedbuilding
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	case room.EdgeBuilding:
		m.ClearBuilding()
		return nil
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgeBuilding:
		m.ResetBuilding()
		return nil
	case room.EdgeUserInformations:
		m.ResetUserInformations()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// StatusRMutation represents an operation that mutate the StatusRs
// nodes in the graph.
type StatusRMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Sname                    *string
	clearedFields             map[string]struct{}
	repair_information        map[int]struct{}
	removedrepair_information map[int]struct{}
	done                      bool
	oldValue                  func(context.Context) (*StatusR, error)
}

var _ ent.Mutation = (*StatusRMutation)(nil)

// statusrOption allows to manage the mutation configuration using functional options.
type statusrOption func(*StatusRMutation)

// newStatusRMutation creates new mutation for $n.Name.
func newStatusRMutation(c config, op Op, opts ...statusrOption) *StatusRMutation {
	m := &StatusRMutation{
		config:        c,
		op:            op,
		typ:           TypeStatusR,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusRID sets the id field of the mutation.
func withStatusRID(id int) statusrOption {
	return func(m *StatusRMutation) {
		var (
			err   error
			once  sync.Once
			value *StatusR
		)
		m.oldValue = func(ctx context.Context) (*StatusR, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatusR.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatusR sets the old StatusR of the mutation.
func withStatusR(node *StatusR) statusrOption {
	return func(m *StatusRMutation) {
		m.oldValue = func(context.Context) (*StatusR, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusRMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusRMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatusRMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSname sets the Sname field.
func (m *StatusRMutation) SetSname(s string) {
	m._Sname = &s
}

// Sname returns the Sname value in the mutation.
func (m *StatusRMutation) Sname() (r string, exists bool) {
	v := m._Sname
	if v == nil {
		return
	}
	return *v, true
}

// OldSname returns the old Sname value of the StatusR.
// If the StatusR object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatusRMutation) OldSname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSname: %w", err)
	}
	return oldValue.Sname, nil
}

// ResetSname reset all changes of the "Sname" field.
func (m *StatusRMutation) ResetSname() {
	m._Sname = nil
}

// AddRepairInformationIDs adds the repair_information edge to RepairInvoice by ids.
func (m *StatusRMutation) AddRepairInformationIDs(ids ...int) {
	if m.repair_information == nil {
		m.repair_information = make(map[int]struct{})
	}
	for i := range ids {
		m.repair_information[ids[i]] = struct{}{}
	}
}

// RemoveRepairInformationIDs removes the repair_information edge to RepairInvoice by ids.
func (m *StatusRMutation) RemoveRepairInformationIDs(ids ...int) {
	if m.removedrepair_information == nil {
		m.removedrepair_information = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrepair_information[ids[i]] = struct{}{}
	}
}

// RemovedRepairInformation returns the removed ids of repair_information.
func (m *StatusRMutation) RemovedRepairInformationIDs() (ids []int) {
	for id := range m.removedrepair_information {
		ids = append(ids, id)
	}
	return
}

// RepairInformationIDs returns the repair_information ids in the mutation.
func (m *StatusRMutation) RepairInformationIDs() (ids []int) {
	for id := range m.repair_information {
		ids = append(ids, id)
	}
	return
}

// ResetRepairInformation reset all changes of the "repair_information" edge.
func (m *StatusRMutation) ResetRepairInformation() {
	m.repair_information = nil
	m.removedrepair_information = nil
}

// Op returns the operation name.
func (m *StatusRMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StatusR).
func (m *StatusRMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatusRMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Sname != nil {
		fields = append(fields, statusr.FieldSname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatusRMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statusr.FieldSname:
		return m.Sname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatusRMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statusr.FieldSname:
		return m.OldSname(ctx)
	}
	return nil, fmt.Errorf("unknown StatusR field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusRMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statusr.FieldSname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSname(v)
		return nil
	}
	return fmt.Errorf("unknown StatusR field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatusRMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatusRMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatusRMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StatusR numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatusRMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatusRMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusRMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StatusR nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatusRMutation) ResetField(name string) error {
	switch name {
	case statusr.FieldSname:
		m.ResetSname()
		return nil
	}
	return fmt.Errorf("unknown StatusR field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatusRMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repair_information != nil {
		edges = append(edges, statusr.EdgeRepairInformation)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatusRMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statusr.EdgeRepairInformation:
		ids := make([]ent.Value, 0, len(m.repair_information))
		for id := range m.repair_information {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatusRMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrepair_information != nil {
		edges = append(edges, statusr.EdgeRepairInformation)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatusRMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statusr.EdgeRepairInformation:
		ids := make([]ent.Value, 0, len(m.removedrepair_information))
		for id := range m.removedrepair_information {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatusRMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatusRMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatusRMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown StatusR unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatusRMutation) ResetEdge(name string) error {
	switch name {
	case statusr.EdgeRepairInformation:
		m.ResetRepairInformation()
		return nil
	}
	return fmt.Errorf("unknown StatusR edge %s", name)
}

// StatustMutation represents an operation that mutate the Statusts
// nodes in the graph.
type StatustMutation struct {
	config
	op              Op
	typ             string
	id              *int
	statustname     *string
	clearedFields   map[string]struct{}
	statusts        map[int]struct{}
	removedstatusts map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Statust, error)
}

var _ ent.Mutation = (*StatustMutation)(nil)

// statustOption allows to manage the mutation configuration using functional options.
type statustOption func(*StatustMutation)

// newStatustMutation creates new mutation for $n.Name.
func newStatustMutation(c config, op Op, opts ...statustOption) *StatustMutation {
	m := &StatustMutation{
		config:        c,
		op:            op,
		typ:           TypeStatust,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatustID sets the id field of the mutation.
func withStatustID(id int) statustOption {
	return func(m *StatustMutation) {
		var (
			err   error
			once  sync.Once
			value *Statust
		)
		m.oldValue = func(ctx context.Context) (*Statust, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statust.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatust sets the old Statust of the mutation.
func withStatust(node *Statust) statustOption {
	return func(m *StatustMutation) {
		m.oldValue = func(context.Context) (*Statust, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatustMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatustMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatustMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatustname sets the statustname field.
func (m *StatustMutation) SetStatustname(s string) {
	m.statustname = &s
}

// Statustname returns the statustname value in the mutation.
func (m *StatustMutation) Statustname() (r string, exists bool) {
	v := m.statustname
	if v == nil {
		return
	}
	return *v, true
}

// OldStatustname returns the old statustname value of the Statust.
// If the Statust object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatustMutation) OldStatustname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatustname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatustname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatustname: %w", err)
	}
	return oldValue.Statustname, nil
}

// ResetStatustname reset all changes of the "statustname" field.
func (m *StatustMutation) ResetStatustname() {
	m.statustname = nil
}

// AddStatustIDs adds the statusts edge to Returninvoice by ids.
func (m *StatustMutation) AddStatustIDs(ids ...int) {
	if m.statusts == nil {
		m.statusts = make(map[int]struct{})
	}
	for i := range ids {
		m.statusts[ids[i]] = struct{}{}
	}
}

// RemoveStatustIDs removes the statusts edge to Returninvoice by ids.
func (m *StatustMutation) RemoveStatustIDs(ids ...int) {
	if m.removedstatusts == nil {
		m.removedstatusts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatusts[ids[i]] = struct{}{}
	}
}

// RemovedStatusts returns the removed ids of statusts.
func (m *StatustMutation) RemovedStatustsIDs() (ids []int) {
	for id := range m.removedstatusts {
		ids = append(ids, id)
	}
	return
}

// StatustsIDs returns the statusts ids in the mutation.
func (m *StatustMutation) StatustsIDs() (ids []int) {
	for id := range m.statusts {
		ids = append(ids, id)
	}
	return
}

// ResetStatusts reset all changes of the "statusts" edge.
func (m *StatustMutation) ResetStatusts() {
	m.statusts = nil
	m.removedstatusts = nil
}

// Op returns the operation name.
func (m *StatustMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Statust).
func (m *StatustMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatustMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.statustname != nil {
		fields = append(fields, statust.FieldStatustname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatustMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statust.FieldStatustname:
		return m.Statustname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatustMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statust.FieldStatustname:
		return m.OldStatustname(ctx)
	}
	return nil, fmt.Errorf("unknown Statust field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatustMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statust.FieldStatustname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatustname(v)
		return nil
	}
	return fmt.Errorf("unknown Statust field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatustMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatustMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatustMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Statust numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatustMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatustMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatustMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Statust nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatustMutation) ResetField(name string) error {
	switch name {
	case statust.FieldStatustname:
		m.ResetStatustname()
		return nil
	}
	return fmt.Errorf("unknown Statust field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatustMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.statusts != nil {
		edges = append(edges, statust.EdgeStatusts)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatustMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statust.EdgeStatusts:
		ids := make([]ent.Value, 0, len(m.statusts))
		for id := range m.statusts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatustMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstatusts != nil {
		edges = append(edges, statust.EdgeStatusts)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatustMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statust.EdgeStatusts:
		ids := make([]ent.Value, 0, len(m.removedstatusts))
		for id := range m.removedstatusts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatustMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatustMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatustMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Statust unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatustMutation) ResetEdge(name string) error {
	switch name {
	case statust.EdgeStatusts:
		m.ResetStatusts()
		return nil
	}
	return fmt.Errorf("unknown Statust edge %s", name)
}

// SymptomMutation represents an operation that mutate the Symptoms
// nodes in the graph.
type SymptomMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Syname                   *string
	clearedFields             map[string]struct{}
	repair_information        map[int]struct{}
	removedrepair_information map[int]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Symptom, error)
}

var _ ent.Mutation = (*SymptomMutation)(nil)

// symptomOption allows to manage the mutation configuration using functional options.
type symptomOption func(*SymptomMutation)

// newSymptomMutation creates new mutation for $n.Name.
func newSymptomMutation(c config, op Op, opts ...symptomOption) *SymptomMutation {
	m := &SymptomMutation{
		config:        c,
		op:            op,
		typ:           TypeSymptom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSymptomID sets the id field of the mutation.
func withSymptomID(id int) symptomOption {
	return func(m *SymptomMutation) {
		var (
			err   error
			once  sync.Once
			value *Symptom
		)
		m.oldValue = func(ctx context.Context) (*Symptom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Symptom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSymptom sets the old Symptom of the mutation.
func withSymptom(node *Symptom) symptomOption {
	return func(m *SymptomMutation) {
		m.oldValue = func(context.Context) (*Symptom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SymptomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SymptomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SymptomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSyname sets the Syname field.
func (m *SymptomMutation) SetSyname(s string) {
	m._Syname = &s
}

// Syname returns the Syname value in the mutation.
func (m *SymptomMutation) Syname() (r string, exists bool) {
	v := m._Syname
	if v == nil {
		return
	}
	return *v, true
}

// OldSyname returns the old Syname value of the Symptom.
// If the Symptom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SymptomMutation) OldSyname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSyname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSyname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyname: %w", err)
	}
	return oldValue.Syname, nil
}

// ResetSyname reset all changes of the "Syname" field.
func (m *SymptomMutation) ResetSyname() {
	m._Syname = nil
}

// AddRepairInformationIDs adds the repair_information edge to RepairInvoice by ids.
func (m *SymptomMutation) AddRepairInformationIDs(ids ...int) {
	if m.repair_information == nil {
		m.repair_information = make(map[int]struct{})
	}
	for i := range ids {
		m.repair_information[ids[i]] = struct{}{}
	}
}

// RemoveRepairInformationIDs removes the repair_information edge to RepairInvoice by ids.
func (m *SymptomMutation) RemoveRepairInformationIDs(ids ...int) {
	if m.removedrepair_information == nil {
		m.removedrepair_information = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrepair_information[ids[i]] = struct{}{}
	}
}

// RemovedRepairInformation returns the removed ids of repair_information.
func (m *SymptomMutation) RemovedRepairInformationIDs() (ids []int) {
	for id := range m.removedrepair_information {
		ids = append(ids, id)
	}
	return
}

// RepairInformationIDs returns the repair_information ids in the mutation.
func (m *SymptomMutation) RepairInformationIDs() (ids []int) {
	for id := range m.repair_information {
		ids = append(ids, id)
	}
	return
}

// ResetRepairInformation reset all changes of the "repair_information" edge.
func (m *SymptomMutation) ResetRepairInformation() {
	m.repair_information = nil
	m.removedrepair_information = nil
}

// Op returns the operation name.
func (m *SymptomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Symptom).
func (m *SymptomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SymptomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Syname != nil {
		fields = append(fields, symptom.FieldSyname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SymptomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case symptom.FieldSyname:
		return m.Syname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SymptomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case symptom.FieldSyname:
		return m.OldSyname(ctx)
	}
	return nil, fmt.Errorf("unknown Symptom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SymptomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case symptom.FieldSyname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyname(v)
		return nil
	}
	return fmt.Errorf("unknown Symptom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SymptomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SymptomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SymptomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Symptom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SymptomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SymptomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SymptomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Symptom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SymptomMutation) ResetField(name string) error {
	switch name {
	case symptom.FieldSyname:
		m.ResetSyname()
		return nil
	}
	return fmt.Errorf("unknown Symptom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SymptomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repair_information != nil {
		edges = append(edges, symptom.EdgeRepairInformation)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SymptomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case symptom.EdgeRepairInformation:
		ids := make([]ent.Value, 0, len(m.repair_information))
		for id := range m.repair_information {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SymptomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrepair_information != nil {
		edges = append(edges, symptom.EdgeRepairInformation)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SymptomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case symptom.EdgeRepairInformation:
		ids := make([]ent.Value, 0, len(m.removedrepair_information))
		for id := range m.removedrepair_information {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SymptomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SymptomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SymptomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Symptom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SymptomMutation) ResetEdge(name string) error {
	switch name {
	case symptom.EdgeRepairInformation:
		m.ResetRepairInformation()
		return nil
	}
	return fmt.Errorf("unknown Symptom edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	personalID                        *string
	personalName                      *string
	clearedFields                     map[string]struct{}
	faculty                           *int
	clearedfaculty                    bool
	branch                            *int
	clearedbranch                     bool
	building                          *int
	clearedbuilding                   bool
	room                              *int
	clearedroom                       bool
	repairinvoice_informations        map[int]struct{}
	removedrepairinvoice_informations map[int]struct{}
	done                              bool
	oldValue                          func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPersonalID sets the personalID field.
func (m *UserMutation) SetPersonalID(s string) {
	m.personalID = &s
}

// PersonalID returns the personalID value in the mutation.
func (m *UserMutation) PersonalID() (r string, exists bool) {
	v := m.personalID
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalID returns the old personalID value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPersonalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPersonalID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPersonalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalID: %w", err)
	}
	return oldValue.PersonalID, nil
}

// ResetPersonalID reset all changes of the "personalID" field.
func (m *UserMutation) ResetPersonalID() {
	m.personalID = nil
}

// SetPersonalName sets the personalName field.
func (m *UserMutation) SetPersonalName(s string) {
	m.personalName = &s
}

// PersonalName returns the personalName value in the mutation.
func (m *UserMutation) PersonalName() (r string, exists bool) {
	v := m.personalName
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalName returns the old personalName value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPersonalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPersonalName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPersonalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalName: %w", err)
	}
	return oldValue.PersonalName, nil
}

// ResetPersonalName reset all changes of the "personalName" field.
func (m *UserMutation) ResetPersonalName() {
	m.personalName = nil
}

// SetFacultyID sets the faculty edge to Faculty by id.
func (m *UserMutation) SetFacultyID(id int) {
	m.faculty = &id
}

// ClearFaculty clears the faculty edge to Faculty.
func (m *UserMutation) ClearFaculty() {
	m.clearedfaculty = true
}

// FacultyCleared returns if the edge faculty was cleared.
func (m *UserMutation) FacultyCleared() bool {
	return m.clearedfaculty
}

// FacultyID returns the faculty id in the mutation.
func (m *UserMutation) FacultyID() (id int, exists bool) {
	if m.faculty != nil {
		return *m.faculty, true
	}
	return
}

// FacultyIDs returns the faculty ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FacultyID instead. It exists only for internal usage by the builders.
func (m *UserMutation) FacultyIDs() (ids []int) {
	if id := m.faculty; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFaculty reset all changes of the "faculty" edge.
func (m *UserMutation) ResetFaculty() {
	m.faculty = nil
	m.clearedfaculty = false
}

// SetBranchID sets the branch edge to Branch by id.
func (m *UserMutation) SetBranchID(id int) {
	m.branch = &id
}

// ClearBranch clears the branch edge to Branch.
func (m *UserMutation) ClearBranch() {
	m.clearedbranch = true
}

// BranchCleared returns if the edge branch was cleared.
func (m *UserMutation) BranchCleared() bool {
	return m.clearedbranch
}

// BranchID returns the branch id in the mutation.
func (m *UserMutation) BranchID() (id int, exists bool) {
	if m.branch != nil {
		return *m.branch, true
	}
	return
}

// BranchIDs returns the branch ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BranchIDs() (ids []int) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch reset all changes of the "branch" edge.
func (m *UserMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// SetBuildingID sets the building edge to Building by id.
func (m *UserMutation) SetBuildingID(id int) {
	m.building = &id
}

// ClearBuilding clears the building edge to Building.
func (m *UserMutation) ClearBuilding() {
	m.clearedbuilding = true
}

// BuildingCleared returns if the edge building was cleared.
func (m *UserMutation) BuildingCleared() bool {
	return m.clearedbuilding
}

// BuildingID returns the building id in the mutation.
func (m *UserMutation) BuildingID() (id int, exists bool) {
	if m.building != nil {
		return *m.building, true
	}
	return
}

// BuildingIDs returns the building ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BuildingID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BuildingIDs() (ids []int) {
	if id := m.building; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuilding reset all changes of the "building" edge.
func (m *UserMutation) ResetBuilding() {
	m.building = nil
	m.clearedbuilding = false
}

// SetRoomID sets the room edge to Room by id.
func (m *UserMutation) SetRoomID(id int) {
	m.room = &id
}

// ClearRoom clears the room edge to Room.
func (m *UserMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared returns if the edge room was cleared.
func (m *UserMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomID returns the room id in the mutation.
func (m *UserMutation) RoomID() (id int, exists bool) {
	if m.room != nil {
		return *m.room, true
	}
	return
}

// RoomIDs returns the room ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RoomIDs() (ids []int) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom reset all changes of the "room" edge.
func (m *UserMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// AddRepairinvoiceInformationIDs adds the repairinvoice_informations edge to RepairInvoice by ids.
func (m *UserMutation) AddRepairinvoiceInformationIDs(ids ...int) {
	if m.repairinvoice_informations == nil {
		m.repairinvoice_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.repairinvoice_informations[ids[i]] = struct{}{}
	}
}

// RemoveRepairinvoiceInformationIDs removes the repairinvoice_informations edge to RepairInvoice by ids.
func (m *UserMutation) RemoveRepairinvoiceInformationIDs(ids ...int) {
	if m.removedrepairinvoice_informations == nil {
		m.removedrepairinvoice_informations = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrepairinvoice_informations[ids[i]] = struct{}{}
	}
}

// RemovedRepairinvoiceInformations returns the removed ids of repairinvoice_informations.
func (m *UserMutation) RemovedRepairinvoiceInformationsIDs() (ids []int) {
	for id := range m.removedrepairinvoice_informations {
		ids = append(ids, id)
	}
	return
}

// RepairinvoiceInformationsIDs returns the repairinvoice_informations ids in the mutation.
func (m *UserMutation) RepairinvoiceInformationsIDs() (ids []int) {
	for id := range m.repairinvoice_informations {
		ids = append(ids, id)
	}
	return
}

// ResetRepairinvoiceInformations reset all changes of the "repairinvoice_informations" edge.
func (m *UserMutation) ResetRepairinvoiceInformations() {
	m.repairinvoice_informations = nil
	m.removedrepairinvoice_informations = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.personalID != nil {
		fields = append(fields, user.FieldPersonalID)
	}
	if m.personalName != nil {
		fields = append(fields, user.FieldPersonalName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldPersonalID:
		return m.PersonalID()
	case user.FieldPersonalName:
		return m.PersonalName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldPersonalID:
		return m.OldPersonalID(ctx)
	case user.FieldPersonalName:
		return m.OldPersonalName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldPersonalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalID(v)
		return nil
	case user.FieldPersonalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldPersonalID:
		m.ResetPersonalID()
		return nil
	case user.FieldPersonalName:
		m.ResetPersonalName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.faculty != nil {
		edges = append(edges, user.EdgeFaculty)
	}
	if m.branch != nil {
		edges = append(edges, user.EdgeBranch)
	}
	if m.building != nil {
		edges = append(edges, user.EdgeBuilding)
	}
	if m.room != nil {
		edges = append(edges, user.EdgeRoom)
	}
	if m.repairinvoice_informations != nil {
		edges = append(edges, user.EdgeRepairinvoiceInformations)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeFaculty:
		if id := m.faculty; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeBuilding:
		if id := m.building; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeRepairinvoiceInformations:
		ids := make([]ent.Value, 0, len(m.repairinvoice_informations))
		for id := range m.repairinvoice_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedrepairinvoice_informations != nil {
		edges = append(edges, user.EdgeRepairinvoiceInformations)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRepairinvoiceInformations:
		ids := make([]ent.Value, 0, len(m.removedrepairinvoice_informations))
		for id := range m.removedrepairinvoice_informations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedfaculty {
		edges = append(edges, user.EdgeFaculty)
	}
	if m.clearedbranch {
		edges = append(edges, user.EdgeBranch)
	}
	if m.clearedbuilding {
		edges = append(edges, user.EdgeBuilding)
	}
	if m.clearedroom {
		edges = append(edges, user.EdgeRoom)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeFaculty:
		return m.clearedfaculty
	case user.EdgeBranch:
		return m.clearedbranch
	case user.EdgeBuilding:
		return m.clearedbuilding
	case user.EdgeRoom:
		return m.clearedroom
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeFaculty:
		m.ClearFaculty()
		return nil
	case user.EdgeBranch:
		m.ClearBranch()
		return nil
	case user.EdgeBuilding:
		m.ClearBuilding()
		return nil
	case user.EdgeRoom:
		m.ClearRoom()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeFaculty:
		m.ResetFaculty()
		return nil
	case user.EdgeBranch:
		m.ResetBranch()
		return nil
	case user.EdgeBuilding:
		m.ResetBuilding()
		return nil
	case user.EdgeRoom:
		m.ResetRoom()
		return nil
	case user.EdgeRepairinvoiceInformations:
		m.ResetRepairinvoiceInformations()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
